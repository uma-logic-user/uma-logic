================================================================================
UMA-Logic PRO - ã‚·ã‚¹ãƒ†ãƒ ç›£æŸ»ç”¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
ä½œæˆæ—¥: 2026-02-03
================================================================================

================================================================================
[1] scripts/ensemble_agents.py - ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«å­¦ç¿’ã‚¨ãƒ³ã‚¸ãƒ³
================================================================================
#!/usr/bin/env python3
# scripts/ensemble_agents.py
# UMA-Logic PRO - ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«å­¦ç¿’ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆå³æ ¼ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆç‰ˆï¼‰
# å®Œå…¨ç‰ˆï¼ˆFull Codeï¼‰- Train/Teståˆ†é›¢ã€ãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯é˜²æ­¢

import json
import math
import random
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field, asdict
import sys

# --- å®šæ•° ---
DATA_DIR = Path("data")
ARCHIVE_DIR = DATA_DIR / "archive"
MODELS_DIR = DATA_DIR / "models"
WEIGHTS_FILE = MODELS_DIR / "weights.json"

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é‡ã¿
DEFAULT_WEIGHTS = {
    "SpeedAgent": 0.35,
    "AdaptabilityAgent": 0.35,
    "PedigreeFormAgent": 0.30
}


# --- ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ ---

@dataclass
class HorseFeatures:
    """
    é¦¬ã®ç‰¹å¾´é‡ï¼ˆãƒ¬ãƒ¼ã‚¹å‰ã«åˆ†ã‹ã‚‹æƒ…å ±ã®ã¿ï¼‰
    â€» ç€é †ã€ã‚¿ã‚¤ãƒ ã€ä¸ŠãŒã‚Š3Fã€æ‰•æˆ»é‡‘ã¯å«ã‚ãªã„ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯é˜²æ­¢ï¼‰
    """
    umaban: int = 0
    horse_name: str = ""
    odds: float = 0.0           # ç™ºèµ°å‰ã‚ªãƒƒã‚º
    popularity: int = 0         # äººæ°—é †
    weight: float = 0.0         # é¦¬ä½“é‡
    weight_diff: float = 0.0    # é¦¬ä½“é‡å¢—æ¸›
    age: int = 0                # é¦¬é½¢
    sex: str = ""               # æ€§åˆ¥
    jockey: str = ""            # é¨æ‰‹
    trainer: str = ""           # èª¿æ•™å¸«
    father: str = ""            # çˆ¶é¦¬
    mother_father: str = ""     # æ¯çˆ¶
    gate_num: int = 0           # æ ç•ª
    # éå»æˆç¸¾ï¼ˆå‰èµ°ä»¥å‰ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ï¼‰
    prev_results: List[int] = field(default_factory=list)  # éå»ã®ç€é †ãƒªã‚¹ãƒˆ
    prev_odds: List[float] = field(default_factory=list)   # éå»ã®ã‚ªãƒƒã‚ºãƒªã‚¹ãƒˆ


@dataclass
class RaceFeatures:
    """ãƒ¬ãƒ¼ã‚¹æ¡ä»¶ï¼ˆãƒ¬ãƒ¼ã‚¹å‰ã«åˆ†ã‹ã‚‹æƒ…å ±ã®ã¿ï¼‰"""
    race_id: str = ""
    race_num: int = 0
    venue: str = ""
    distance: int = 0
    track_type: str = ""        # èŠ/ãƒ€ãƒ¼ãƒˆ
    track_condition: str = ""   # è‰¯/ç¨é‡/é‡/ä¸è‰¯
    grade: str = ""             # ã‚¯ãƒ©ã‚¹
    race_name: str = ""
    date: str = ""


@dataclass
class RaceResult:
    """ãƒ¬ãƒ¼ã‚¹çµæœï¼ˆæ¤œè¨¼ç”¨ã€å­¦ç¿’ã«ã¯ä½¿ç”¨ã—ãªã„ï¼‰"""
    race_id: str = ""
    winner_umaban: int = 0      # 1ç€é¦¬ç•ª
    winner_odds: float = 0.0    # 1ç€é¦¬ã‚ªãƒƒã‚º
    top3_umaban: List[int] = field(default_factory=list)  # 1-3ç€é¦¬ç•ª


# --- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ ---

class SpeedAgent:
    """
    ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    ã‚ªãƒƒã‚ºã¨äººæ°—ã‹ã‚‰æœŸå¾…ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’æ¨å®š
    """
    
    def __init__(self, weight: float = 0.35):
        self.weight = weight
        self.name = "SpeedAgent"
    
    def calculate_score(self, horse: HorseFeatures, race: RaceFeatures) -> float:
        """ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
        score = 50.0
        
        # ã‚ªãƒƒã‚ºãŒä½ã„ï¼ˆäººæ°—ãŒã‚ã‚‹ï¼‰ã»ã©é«˜ã‚¹ã‚³ã‚¢
        if horse.odds > 0:
            if horse.odds < 2.0:
                score += 30
            elif horse.odds < 5.0:
                score += 20
            elif horse.odds < 10.0:
                score += 10
            elif horse.odds < 20.0:
                score += 0
            else:
                score -= 10
        
        # äººæ°—é †
        if horse.popularity > 0:
            if horse.popularity <= 3:
                score += 15
            elif horse.popularity <= 6:
                score += 5
            else:
                score -= 5
        
        # éå»æˆç¸¾ï¼ˆå‰èµ°ä»¥å‰ï¼‰
        if horse.prev_results:
            avg_result = sum(horse.prev_results[:3]) / len(horse.prev_results[:3])
            if avg_result <= 3:
                score += 20
            elif avg_result <= 5:
                score += 10
            elif avg_result <= 8:
                score += 0
            else:
                score -= 10
        
        # è·é›¢é©æ€§ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        if race.distance > 0:
            if race.distance <= 1400:
                # çŸ­è·é›¢ã¯å†…æ æœ‰åˆ©
                if horse.gate_num <= 4:
                    score += 5
            elif race.distance >= 2000:
                # é•·è·é›¢ã¯å·®ã—é¦¬æœ‰åˆ©ï¼ˆäººæ°—è–„ã§ã‚‚ï¼‰
                if horse.popularity > 5 and horse.odds < 30:
                    score += 5
        
        return max(0, min(100, score))


class AdaptabilityAgent:
    """
    é©å¿œæ€§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    é¦¬å ´çŠ¶æ…‹ã€æ é †ã€ã‚³ãƒ¼ã‚¹é©æ€§ã‚’è©•ä¾¡
    """
    
    def __init__(self, weight: float = 0.35):
        self.weight = weight
        self.name = "AdaptabilityAgent"
    
    def calculate_score(self, horse: HorseFeatures, race: RaceFeatures) -> float:
        """é©å¿œæ€§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
        score = 50.0
        
        # æ é †è©•ä¾¡
        if race.distance > 0 and horse.gate_num > 0:
            if race.distance <= 1400:
                # çŸ­è·é›¢ã¯å†…æ æœ‰åˆ©
                if horse.gate_num <= 3:
                    score += 15
                elif horse.gate_num <= 5:
                    score += 5
                elif horse.gate_num >= 7:
                    score -= 5
            elif race.distance <= 1800:
                # ä¸­è·é›¢ã¯ãƒ•ãƒ©ãƒƒãƒˆ
                pass
            else:
                # é•·è·é›¢ã¯å¤–æ ä¸åˆ©
                if horse.gate_num >= 7:
                    score -= 10
        
        # é¦¬å ´çŠ¶æ…‹
        if race.track_condition:
            if race.track_condition in ["é‡", "ä¸è‰¯"]:
                # é‡é¦¬å ´ã¯é¦¬ä½“é‡ãŒé‡ã„é¦¬æœ‰åˆ©
                if horse.weight >= 500:
                    score += 10
                elif horse.weight <= 440:
                    score -= 5
        
        # é¦¬ä½“é‡å¢—æ¸›
        if horse.weight_diff != 0:
            if abs(horse.weight_diff) > 20:
                score -= 10  # å¤§å¹…å¢—æ¸›ã¯ãƒã‚¤ãƒŠã‚¹
            elif -10 <= horse.weight_diff <= 10:
                score += 5   # å®‰å®šã¯ãƒ—ãƒ©ã‚¹
        
        # å¹´é½¢
        if horse.age > 0:
            if horse.age == 3:
                score += 5   # 3æ­³ã¯æˆé•·æœŸ
            elif horse.age >= 7:
                score -= 5   # é«˜é½¢é¦¬ã¯æ¸›ç‚¹
        
        return max(0, min(100, score))


class PedigreeFormAgent:
    """
    è¡€çµ±ãƒ»èª¿å­ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    è¡€çµ±ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ç›´è¿‘ã®èª¿å­ã‚’è©•ä¾¡
    """
    
    # æœ‰åç¨®ç‰¡é¦¬ã®ã‚¹ã‚³ã‚¢è£œæ­£
    SIRE_BONUS = {
        "ãƒ‡ã‚£ãƒ¼ãƒ—ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ": 15,
        "ã‚­ãƒ³ã‚°ã‚«ãƒ¡ãƒãƒ¡ãƒ": 12,
        "ãƒ­ãƒ¼ãƒ‰ã‚«ãƒŠãƒ­ã‚¢": 12,
        "ãƒãƒ¼ãƒ„ã‚¯ãƒ©ã‚¤": 10,
        "ã‚¨ãƒ”ãƒ•ã‚¡ãƒã‚¤ã‚¢": 10,
        "ãƒ‰ã‚¥ãƒ©ãƒ¡ãƒ³ãƒ†": 10,
        "ã‚­ã‚¿ã‚µãƒ³ãƒ–ãƒ©ãƒƒã‚¯": 10,
        "ãƒ¢ãƒ¼ãƒªã‚¹": 8,
        "ã‚ªãƒ«ãƒ•ã‚§ãƒ¼ãƒ´ãƒ«": 8,
        "ã‚´ãƒ¼ãƒ«ãƒ‰ã‚·ãƒƒãƒ—": 5,
    }
    
    def __init__(self, weight: float = 0.30):
        self.weight = weight
        self.name = "PedigreeFormAgent"
    
    def calculate_score(self, horse: HorseFeatures, race: RaceFeatures) -> float:
        """è¡€çµ±ãƒ»èª¿å­ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
        score = 50.0
        
        # è¡€çµ±è©•ä¾¡
        if horse.father:
            bonus = self.SIRE_BONUS.get(horse.father, 0)
            score += bonus
        
        # éå»æˆç¸¾ã®å‚¾å‘ï¼ˆä¸Šæ˜‡å‚¾å‘ã‹ä¸‹é™å‚¾å‘ã‹ï¼‰
        if len(horse.prev_results) >= 2:
            recent = horse.prev_results[0]  # æœ€æ–°
            older = horse.prev_results[1]   # 1ã¤å‰
            
            if recent < older:
                score += 10  # ä¸Šæ˜‡å‚¾å‘
            elif recent > older:
                score -= 5   # ä¸‹é™å‚¾å‘
        
        # ã‚ªãƒƒã‚ºã¨éå»æˆç¸¾ã®ä¹–é›¢ï¼ˆç©´é¦¬ç™ºè¦‹ï¼‰
        if horse.prev_results and horse.odds > 0:
            avg_result = sum(horse.prev_results[:3]) / len(horse.prev_results[:3])
            
            # éå»æˆç¸¾ãŒè‰¯ã„ã®ã«ã‚ªãƒƒã‚ºãŒé«˜ã„ â†’ ç©´é¦¬å€™è£œ
            if avg_result <= 5 and horse.odds >= 10:
                score += 15
            # éå»æˆç¸¾ãŒæ‚ªã„ã®ã«ã‚ªãƒƒã‚ºãŒä½ã„ â†’ éå¤§è©•ä¾¡
            elif avg_result >= 8 and horse.odds < 5:
                score -= 10
        
        # é¨æ‰‹è©•ä¾¡ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        TOP_JOCKEYS = ["ãƒ«ãƒ¡ãƒ¼ãƒ«", "å·ç”°å°†é›…", "æˆ¸å´åœ­å¤ª", "æ¨ªå±±æ­¦å²", "ç¦æ°¸ç¥ä¸€", "æ­¦è±Š"]
        if horse.jockey in TOP_JOCKEYS:
            score += 10
        
        return max(0, min(100, score))


# --- çµ±åˆè¨ˆç®—ã‚¯ãƒ©ã‚¹ ---

class IntegratedCalculator:
    """
    ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«çµ±åˆè¨ˆç®—æ©Ÿ
    3ã¤ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¹ã‚³ã‚¢ã‚’çµ±åˆ
    """
    
    def __init__(self):
        self.weights = self._load_weights()
        self.agents = {
            "SpeedAgent": SpeedAgent(self.weights.get("SpeedAgent", 0.35)),
            "AdaptabilityAgent": AdaptabilityAgent(self.weights.get("AdaptabilityAgent", 0.35)),
            "PedigreeFormAgent": PedigreeFormAgent(self.weights.get("PedigreeFormAgent", 0.30)),
        }
    
    def _load_weights(self) -> Dict[str, float]:
        """ä¿å­˜ã•ã‚ŒãŸé‡ã¿ã‚’èª­ã¿è¾¼ã¿"""
        if WEIGHTS_FILE.exists():
            try:
                with open(WEIGHTS_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return data.get("weights", DEFAULT_WEIGHTS)
            except Exception:
                pass
        return DEFAULT_WEIGHTS.copy()
    
    def calculate_integrated_score(self, horse: HorseFeatures, race: RaceFeatures) -> float:
        """çµ±åˆã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—"""
        total_score = 0.0
        total_weight = 0.0
        
        for agent_name, agent in self.agents.items():
            score = agent.calculate_score(horse, race)
            weight = self.weights.get(agent_name, agent.weight)
            total_score += score * weight
            total_weight += weight
        
        if total_weight > 0:
            return total_score / total_weight
        return 50.0
    
    def predict_race(self, horses: List[HorseFeatures], race: RaceFeatures) -> List[Tuple[int, str, float]]:
        """
        ãƒ¬ãƒ¼ã‚¹ã®äºˆæ¸¬ã‚’è¡Œã„ã€æ¨å¥¨é¦¬ã‚’ãƒ©ãƒ³ã‚­ãƒ³ã‚°
        Returns: [(é¦¬ç•ª, é¦¬å, ã‚¹ã‚³ã‚¢), ...]
        """
        results = []
        for horse in horses:
            score = self.calculate_integrated_score(horse, race)
            results.append((horse.umaban, horse.horse_name, score))
        
        # ã‚¹ã‚³ã‚¢é™é †ã§ã‚½ãƒ¼ãƒˆ
        results.sort(key=lambda x: x[2], reverse=True)
        return results


# --- ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ ---

class StrictBacktester:
    """
    å³æ ¼ãªãƒãƒƒã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼
    Train/Teståˆ†é›¢ã€ãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯é˜²æ­¢
    """
    
    def __init__(self, train_years: List[int], test_years: List[int]):
        self.train_years = train_years
        self.test_years = test_years
        self.calculator = IntegratedCalculator()
    
    def load_race_data(self, year: int) -> List[Dict]:
        """æŒ‡å®šå¹´ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿"""
        races = []
        
        # ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‹ã‚‰èª­ã¿è¾¼ã¿
        year_dir = ARCHIVE_DIR / str(year)
        if year_dir.exists():
            for month_dir in sorted(year_dir.iterdir()):
                if month_dir.is_dir():
                    for day_dir in sorted(month_dir.iterdir()):
                        if day_dir.is_dir():
                            for json_file in day_dir.glob("*.json"):
                                try:
                                    with open(json_file, 'r', encoding='utf-8') as f:
                                        data = json.load(f)
                                        if "races" in data:
                                            races.extend(data["races"])
                                except Exception:
                                    continue
        
        # data/ ç›´ä¸‹ã‹ã‚‰ã‚‚èª­ã¿è¾¼ã¿
        for json_file in DATA_DIR.glob(f"results_{year}*.json"):
            try:
                with open(json_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    if "races" in data:
                        races.extend(data["races"])
            except Exception:
                continue
        
        return races
    
    def extract_features(self, race_data: Dict) -> Tuple[RaceFeatures, List[HorseFeatures], Optional[RaceResult]]:
        """
        ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç‰¹å¾´é‡ã‚’æŠ½å‡º
        â€» çµæœãƒ‡ãƒ¼ã‚¿ï¼ˆç€é †ã€ã‚¿ã‚¤ãƒ ï¼‰ã¯ç‰¹å¾´é‡ã«å«ã‚ãªã„
        """
        race = RaceFeatures(
            race_id=race_data.get("race_id", ""),
            race_num=race_data.get("race_num", 0),
            venue=race_data.get("venue", ""),
            distance=race_data.get("distance", 0),
            track_type=race_data.get("track_type", ""),
            track_condition=race_data.get("track_condition", ""),
            grade=race_data.get("grade", ""),
            race_name=race_data.get("race_name", ""),
            date=race_data.get("date", ""),
        )
        
        horses = []
        all_results = race_data.get("all_results", [])
        top3 = race_data.get("top3", [])
        
        # å‡ºèµ°é¦¬ã®æƒ…å ±ã‚’å–å¾—
        horse_list = all_results if all_results else top3
        
        for h in horse_list:
            # ç€é †ã€ã‚¿ã‚¤ãƒ ã€ä¸ŠãŒã‚Š3Fã¯ç‰¹å¾´é‡ã«å«ã‚ãªã„ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯é˜²æ­¢ï¼‰
            horse = HorseFeatures(
                umaban=int(h.get("é¦¬ç•ª", h.get("umaban", 0))),
                horse_name=h.get("é¦¬å", h.get("horse_name", "")),
                odds=float(h.get("ã‚ªãƒƒã‚º", h.get("odds", 0)) or 0),
                popularity=int(h.get("äººæ°—", h.get("popularity", 0)) or 0),
                weight=float(h.get("é¦¬ä½“é‡", h.get("weight", 0)) or 0),
                weight_diff=float(h.get("å¢—æ¸›", h.get("weight_diff", 0)) or 0),
                jockey=h.get("é¨æ‰‹", h.get("jockey", "")),
                gate_num=int(h.get("æ ç•ª", h.get("gate_num", 0)) or 0),
            )
            horses.append(horse)
        
        # çµæœãƒ‡ãƒ¼ã‚¿ï¼ˆæ¤œè¨¼ç”¨ï¼‰
        result = None
        if top3:
            winner = top3[0] if top3 else {}
            result = RaceResult(
                race_id=race.race_id,
                winner_umaban=int(winner.get("é¦¬ç•ª", winner.get("umaban", 0)) or 0),
                winner_odds=float(winner.get("ã‚ªãƒƒã‚º", winner.get("odds", 0)) or 0),
                top3_umaban=[int(h.get("é¦¬ç•ª", h.get("umaban", 0)) or 0) for h in top3[:3]],
            )
        
        return race, horses, result
    
    def evaluate_prediction(self, prediction: List[Tuple[int, str, float]], result: RaceResult) -> Dict:
        """
        äºˆæ¸¬çµæœã‚’è©•ä¾¡
        â—ï¼ˆ1ä½äºˆæ¸¬ï¼‰ãŒ1ç€ã«ãªã£ãŸã‹ã§åˆ¤å®š
        """
        if not prediction or not result or result.winner_umaban == 0:
            return {"hit": False, "investment": 0, "return": 0}
        
        # â—ï¼ˆæœ€é«˜ã‚¹ã‚³ã‚¢ã®é¦¬ï¼‰ã‚’äºˆæ¸¬
        top_pick_umaban = prediction[0][0]
        
        # çš„ä¸­åˆ¤å®šï¼šâ—ãŒ1ç€ã«ãªã£ãŸã‹
        hit = (top_pick_umaban == result.winner_umaban)
        
        # æŠ•è³‡é¡ï¼ˆå˜å‹100å††ï¼‰
        investment = 100
        
        # æ‰•æˆ»é‡‘
        if hit and result.winner_odds > 0:
            payout = int(result.winner_odds * 100)
        else:
            payout = 0
        
        return {
            "hit": hit,
            "investment": investment,
            "return": payout,
            "predicted_umaban": top_pick_umaban,
            "winner_umaban": result.winner_umaban,
            "winner_odds": result.winner_odds,
        }
    
    def run_backtest(self, years: List[int], weights: Dict[str, float]) -> Dict:
        """
        æŒ‡å®šã—ãŸé‡ã¿ã§ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
        """
        # é‡ã¿ã‚’é©ç”¨
        self.calculator.weights = weights
        for agent_name, agent in self.calculator.agents.items():
            agent.weight = weights.get(agent_name, agent.weight)
        
        total_races = 0
        total_hits = 0
        total_investment = 0
        total_return = 0
        
        for year in years:
            races = self.load_race_data(year)
            
            for race_data in races:
                race, horses, result = self.extract_features(race_data)
                
                if not horses or not result:
                    continue
                
                # äºˆæ¸¬
                prediction = self.calculator.predict_race(horses, race)
                
                # è©•ä¾¡
                eval_result = self.evaluate_prediction(prediction, result)
                
                total_races += 1
                if eval_result["hit"]:
                    total_hits += 1
                total_investment += eval_result["investment"]
                total_return += eval_result["return"]
        
        hit_rate = total_hits / total_races if total_races > 0 else 0
        recovery_rate = total_return / total_investment if total_investment > 0 else 0
        
        return {
            "total_races": total_races,
            "total_hits": total_hits,
            "hit_rate": hit_rate,
            "recovery_rate": recovery_rate,
            "total_investment": total_investment,
            "total_return": total_return,
        }
    
    def optimize_weights(self, iterations: int = 100, learning_rate: float = 0.1) -> Dict:
        """
        Train ãƒ‡ãƒ¼ã‚¿ã§é‡ã¿ã‚’æœ€é©åŒ–ã—ã€Test ãƒ‡ãƒ¼ã‚¿ã§æ¤œè¨¼
        """
        print("\n" + "=" * 60)
        print("ğŸ§  é‡ã¿æœ€é©åŒ–é–‹å§‹ï¼ˆå³æ ¼ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆç‰ˆï¼‰")
        print("=" * 60)
        print(f"[INFO] å­¦ç¿’ãƒ‡ãƒ¼ã‚¿: {self.train_years}")
        print(f"[INFO] ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿: {self.test_years}")
        print(f"[INFO] ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: {iterations}")
        print(f"[INFO] å­¦ç¿’ç‡: {learning_rate}")
        
        # åˆæœŸé‡ã¿
        best_weights = DEFAULT_WEIGHTS.copy()
        best_score = -float('inf')
        
        # å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã§ã®åˆæœŸè©•ä¾¡
        print("\n[PHASE 1] å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã§æœ€é©åŒ–ä¸­...")
        
        for i in range(iterations):
            # é‡ã¿ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰å‹•
            new_weights = {}
            for key in best_weights:
                delta = random.uniform(-learning_rate, learning_rate)
                new_weights[key] = max(0.05, min(0.9, best_weights[key] + delta))
            
            # æ­£è¦åŒ–
            total = sum(new_weights.values())
            new_weights = {k: v / total for k, v in new_weights.items()}
            
            # å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã§è©•ä¾¡
            result = self.run_backtest(self.train_years, new_weights)
            
            # ã‚¹ã‚³ã‚¢ = å›åç‡ï¼ˆçš„ä¸­ç‡ã ã‘ã§ãªãã€å›åç‡ã‚’é‡è¦–ï¼‰
            score = result["recovery_rate"]
            
            if score > best_score:
                best_score = score
                best_weights = new_weights.copy()
                
                if (i + 1) % 20 == 0:
                    print(f"  [{i+1}/{iterations}] å›åç‡: {score*100:.2f}% (çš„ä¸­ç‡: {result['hit_rate']*100:.2f}%)")
        
        # ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§æ¤œè¨¼
        print("\n[PHASE 2] ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§æ¤œè¨¼ä¸­...")
        train_result = self.run_backtest(self.train_years, best_weights)
        test_result = self.run_backtest(self.test_years, best_weights)
        
        print("\n" + "=" * 60)
        print("ğŸ“Š æœ€é©åŒ–çµæœ")
        print("=" * 60)
        
        print("\nã€å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆTrainï¼‰ã€‘")
        print(f"  å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æ•°: {train_result['total_races']:,}")
        print(f"  çš„ä¸­æ•°: {train_result['total_hits']:,}")
        print(f"  çš„ä¸­ç‡: {train_result['hit_rate']*100:.2f}%")
        print(f"  å›åç‡: {train_result['recovery_rate']*100:.2f}%")
        
        print("\nã€ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ï¼ˆTestï¼‰ã€‘")
        print(f"  å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æ•°: {test_result['total_races']:,}")
        print(f"  çš„ä¸­æ•°: {test_result['total_hits']:,}")
        print(f"  çš„ä¸­ç‡: {test_result['hit_rate']*100:.2f}%")
        print(f"  å›åç‡: {test_result['recovery_rate']*100:.2f}%")
        
        print("\nã€æœ€é©åŒ–ã•ã‚ŒãŸé‡ã¿ã€‘")
        for agent, weight in best_weights.items():
            print(f"  {agent}: {weight*100:.1f}%")
        
        # çµæœã‚’ä¿å­˜
        result_data = {
            "weights": best_weights,
            "updated_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "train_metrics": {
                "years": self.train_years,
                "total_races": train_result["total_races"],
                "hit_rate": train_result["hit_rate"],
                "recovery_rate": train_result["recovery_rate"],
            },
            "test_metrics": {
                "years": self.test_years,
                "total_races": test_result["total_races"],
                "hit_rate": test_result["hit_rate"],
                "recovery_rate": test_result["recovery_rate"],
            },
            "metrics": {
                "total_races": test_result["total_races"],
                "correct_predictions": test_result["total_hits"],
                "hit_rate": test_result["hit_rate"],
                "recovery_rate": test_result["recovery_rate"],
                "total_investment": test_result["total_investment"],
                "total_return": test_result["total_return"],
            }
        }
        
        # ä¿å­˜
        MODELS_DIR.mkdir(parents=True, exist_ok=True)
        with open(WEIGHTS_FILE, 'w', encoding='utf-8') as f:
            json.dump(result_data, f, ensure_ascii=False, indent=2)
        
        print(f"\nâœ… é‡ã¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {WEIGHTS_FILE}")
        
        return result_data


# --- ãƒ¡ã‚¤ãƒ³é–¢æ•° ---

def main():
    """ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    print("=" * 60)
    print("ğŸ§  UMA-Logic PRO - ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«å­¦ç¿’ã‚¨ãƒ³ã‚¸ãƒ³")
    print("   ï¼ˆå³æ ¼ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆç‰ˆ - ãƒ‡ãƒ¼ã‚¿ãƒªãƒ¼ã‚¯é˜²æ­¢ï¼‰")
    print("=" * 60)
    
    args = sys.argv[1:]
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    train_years = [2024]
    test_years = [2025]
    iterations = 100
    learning_rate = 0.1
    source_dir = None
    
    # å¼•æ•°è§£æ
    i = 0
    while i < len(args):
        if args[i] == "--optimize":
            i += 1
        elif args[i] == "--source" and i + 1 < len(args):
            source_dir = args[i + 1]
            # ã‚½ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰å¹´ã‚’æ¨å®š
            if "2024" in source_dir:
                train_years = [2024]
                test_years = [2025]
            elif "2025" in source_dir:
                train_years = [2024]
                test_years = [2025]
            i += 2
        elif args[i] == "--train-years" and i + 1 < len(args):
            train_years = [int(y) for y in args[i + 1].split(",")]
            i += 2
        elif args[i] == "--test-years" and i + 1 < len(args):
            test_years = [int(y) for y in args[i + 1].split(",")]
            i += 2
        elif args[i] == "--iterations" and i + 1 < len(args):
            iterations = int(args[i + 1])
            i += 2
        elif args[i] == "--learning-rate" and i + 1 < len(args):
            learning_rate = float(args[i + 1])
            i += 2
        else:
            i += 1
    
    if "--optimize" in args or not args:
        # æœ€é©åŒ–å®Ÿè¡Œ
        backtester = StrictBacktester(train_years, test_years)
        result = backtester.optimize_weights(iterations, learning_rate)
        
        print("\n" + "=" * 60)
        print("âœ… å‡¦ç†å®Œäº†")
        print("=" * 60)
    
    elif "--backtest" in args:
        # ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã®ã¿å®Ÿè¡Œ
        backtester = StrictBacktester(train_years, test_years)
        
        print("\n[INFO] ç¾åœ¨ã®é‡ã¿ã§ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...")
        
        weights = backtester.calculator.weights
        train_result = backtester.run_backtest(train_years, weights)
        test_result = backtester.run_backtest(test_years, weights)
        
        print("\nã€å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã€‘")
        print(f"  çš„ä¸­ç‡: {train_result['hit_rate']*100:.2f}%")
        print(f"  å›åç‡: {train_result['recovery_rate']*100:.2f}%")
        
        print("\nã€ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã€‘")
        print(f"  çš„ä¸­ç‡: {test_result['hit_rate']*100:.2f}%")
        print(f"  å›åç‡: {test_result['recovery_rate']*100:.2f}%")
    
    elif "--show-weights" in args:
        # ç¾åœ¨ã®é‡ã¿ã‚’è¡¨ç¤º
        calculator = IntegratedCalculator()
        print("\nã€ç¾åœ¨ã®é‡ã¿ã€‘")
        for agent, weight in calculator.weights.items():
            print(f"  {agent}: {weight*100:.1f}%")
    
    else:
        print("\nä½¿ç”¨æ–¹æ³•:")
        print("  python ensemble_agents.py --optimize")
        print("  python ensemble_agents.py --optimize --train-years 2024 --test-years 2025")
        print("  python ensemble_agents.py --optimize --iterations 200 --learning-rate 0.05")
        print("  python ensemble_agents.py --backtest")
        print("  python ensemble_agents.py --show-weights")


if __name__ == "__main__":
    main()

================================================================================
[2] scripts/notifier.py - é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
================================================================================
# scripts/notifier.py
# UMA-Logic PRO - é€šçŸ¥æ©Ÿèƒ½ï¼ˆDiscord/LINE/Slackå¯¾å¿œï¼‰
# å®Œå…¨ç‰ˆï¼ˆFull Codeï¼‰- ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã§å‹•ä½œ

import os
import json
import requests
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import sys

# --- å®šæ•° ---
DATA_DIR = Path("data")
PREDICTIONS_PREFIX = "predictions_"
RESULTS_PREFIX = "results_"
ALERTS_FILE = DATA_DIR / "insider_alerts.json"
HISTORY_FILE = DATA_DIR / "history.json"
WEIGHTS_FILE = DATA_DIR / "models" / "weights.json"

# ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
DISCORD_WEBHOOK = os.environ.get("DISCORD_WEBHOOK", "")
LINE_NOTIFY_TOKEN = os.environ.get("LINE_NOTIFY_TOKEN", "")
SLACK_WEBHOOK = os.environ.get("SLACK_WEBHOOK", "")


# --- é€šçŸ¥ã‚¯ãƒ©ã‚¹ ---

class Notifier:
    """
    ãƒãƒ«ãƒãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ é€šçŸ¥ã‚¯ãƒ©ã‚¹
    Discord, LINE Notify, Slack ã«å¯¾å¿œ
    """

    def __init__(self):
        self.discord_webhook = DISCORD_WEBHOOK
        self.line_token = LINE_NOTIFY_TOKEN
        self.slack_webhook = SLACK_WEBHOOK
        self.available_platforms = self._check_platforms()

    def _check_platforms(self) -> List[str]:
        """åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’ç¢ºèª"""
        platforms = []
        if self.discord_webhook:
            platforms.append("discord")
        if self.line_token:
            platforms.append("line")
        if self.slack_webhook:
            platforms.append("slack")
        return platforms

    def send_discord(self, title: str, message: str, color: int = 0x4ade80, fields: List[Dict] = None) -> bool:
        """Discordã«é€šçŸ¥ã‚’é€ä¿¡"""
        if not self.discord_webhook:
            return False

        embed = {
            "title": title,
            "description": message,
            "color": color,
            "timestamp": datetime.utcnow().isoformat(),
            "footer": {"text": "UMA-Logic PRO"}
        }

        if fields:
            embed["fields"] = fields

        payload = {
            "embeds": [embed]
        }

        try:
            response = requests.post(
                self.discord_webhook,
                json=payload,
                timeout=10
            )
            return response.status_code == 204
        except Exception as e:
            print(f"[ERROR] Discordé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def send_line(self, message: str) -> bool:
        """LINE Notifyã«é€šçŸ¥ã‚’é€ä¿¡"""
        if not self.line_token:
            return False

        headers = {
            "Authorization": f"Bearer {self.line_token}"
        }

        payload = {
            "message": message
        }

        try:
            response = requests.post(
                "https://notify-api.line.me/api/notify",
                headers=headers,
                data=payload,
                timeout=10
            )
            return response.status_code == 200
        except Exception as e:
            print(f"[ERROR] LINEé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def send_slack(self, title: str, message: str, color: str = "#4ade80", fields: List[Dict] = None) -> bool:
        """Slackã«é€šçŸ¥ã‚’é€ä¿¡"""
        if not self.slack_webhook:
            return False

        attachment = {
            "color": color,
            "title": title,
            "text": message,
            "footer": "UMA-Logic PRO",
            "ts": int(datetime.now().timestamp())
        }

        if fields:
            attachment["fields"] = [
                {"title": f["name"], "value": f["value"], "short": True}
                for f in fields
            ]

        payload = {
            "attachments": [attachment]
        }

        try:
            response = requests.post(
                self.slack_webhook,
                json=payload,
                timeout=10
            )
            return response.status_code == 200
        except Exception as e:
            print(f"[ERROR] Slacké€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def send_all(self, title: str, message: str, color: int = 0x4ade80, fields: List[Dict] = None):
        """å…¨ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«é€šçŸ¥ã‚’é€ä¿¡"""
        results = {}

        if "discord" in self.available_platforms:
            results["discord"] = self.send_discord(title, message, color, fields)

        if "line" in self.available_platforms:
            # LINEã¯ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚­ã‚¹ãƒˆã®ã¿
            line_message = f"\n{title}\n\n{message}"
            if fields:
                for f in fields:
                    line_message += f"\n{f['name']}: {f['value']}"
            results["line"] = self.send_line(line_message)

        if "slack" in self.available_platforms:
            slack_color = f"#{color:06x}" if isinstance(color, int) else color
            results["slack"] = self.send_slack(title, message, slack_color, fields)

        return results


# --- é€šçŸ¥ã‚¿ã‚¤ãƒ—åˆ¥é–¢æ•° ---

def notify_predictions(status: str = "success"):
    """äºˆæƒ³ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†é€šçŸ¥"""
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    # æœ¬æ—¥ã®äºˆæƒ³ã‚’èª­ã¿è¾¼ã¿
    today_str = datetime.now().strftime("%Y%m%d")
    pred_file = DATA_DIR / f"{PREDICTIONS_PREFIX}{today_str}.json"

    title = "ğŸ äºˆæƒ³ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†"
    message = f"æœ¬æ—¥ ({datetime.now().strftime('%m/%d')}) ã®äºˆæƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸã€‚"
    color = 0x4ade80 if status == "success" else 0xef4444
    fields = []

    if pred_file.exists():
        try:
            with open(pred_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            races = data.get("races", [])
            fields.append({"name": "ğŸ“Š ãƒ¬ãƒ¼ã‚¹æ•°", "value": f"{len(races)}ãƒ¬ãƒ¼ã‚¹", "inline": True})

            # æ¨å¥¨é¦¬ã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—
            top_picks = []
            for race in races[:3]:
                venue = race.get("venue", "")
                race_num = race.get("race_num", 0)
                top3 = race.get("top3", [])
                if top3:
                    horse = top3[0]
                    horse_name = horse.get("horse_name", horse.get("é¦¬å", ""))
                    top_picks.append(f"{venue}{race_num}R: {horse_name}")

            if top_picks:
                fields.append({"name": "ğŸ¯ æ³¨ç›®é¦¬", "value": "\n".join(top_picks), "inline": False})

        except Exception as e:
            print(f"[WARN] äºˆæƒ³ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


def notify_results(status: str = "success"):
    """ãƒ¬ãƒ¼ã‚¹çµæœå–å¾—å®Œäº†é€šçŸ¥"""
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    today_str = datetime.now().strftime("%Y%m%d")
    results_file = DATA_DIR / f"{RESULTS_PREFIX}{today_str}.json"

    title = "ğŸ“Š ãƒ¬ãƒ¼ã‚¹çµæœå–å¾—å®Œäº†"
    message = f"æœ¬æ—¥ ({datetime.now().strftime('%m/%d')}) ã®ãƒ¬ãƒ¼ã‚¹çµæœã‚’å–å¾—ã—ã¾ã—ãŸã€‚"
    color = 0x60a5fa
    fields = []

    if results_file.exists():
        try:
            with open(results_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            races = data.get("races", [])
            fields.append({"name": "ğŸ“Š ãƒ¬ãƒ¼ã‚¹æ•°", "value": f"{len(races)}ãƒ¬ãƒ¼ã‚¹", "inline": True})
        except Exception:
            pass

    # çš„ä¸­æƒ…å ±ã‚’ç¢ºèª
    if HISTORY_FILE.exists():
        try:
            with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                history = json.load(f)
            today_hits = [h for h in history if h.get("date") == today_str]
            if today_hits:
                total_payout = sum(h.get("payout", 0) for h in today_hits)
                fields.append({"name": "ğŸ‰ æœ¬æ—¥ã®çš„ä¸­", "value": f"{len(today_hits)}ä»¶", "inline": True})
                fields.append({"name": "ğŸ’° æ‰•æˆ»é‡‘", "value": f"Â¥{total_payout:,}", "inline": True})
                color = 0x4ade80  # çš„ä¸­ãŒã‚ã‚Œã°ç·‘è‰²
        except Exception:
            pass

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


def notify_optimize(status: str = "success"):
    """
    AIå­¦ç¿’å®Œäº†é€šçŸ¥
    weights.json ã®æ­£ã—ã„éšå±¤æ§‹é€ ã‚’èª­ã¿å–ã‚‹
    
    weights.json ã®æ§‹é€ :
    {
        "weights": { "SpeedAgent": 0.35, ... },
        "train_metrics": { "hit_rate": 0.46, "recovery_rate": 1.26, ... },
        "test_metrics": { "hit_rate": 0.44, "recovery_rate": 1.21, ... },
        "metrics": { ... }
    }
    """
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    title = "ğŸ§  AIå­¦ç¿’å®Œäº†"
    message = "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é‡ã¿æœ€é©åŒ–ãŒå®Œäº†ã—ã¾ã—ãŸã€‚"
    color = 0xa855f7 if status == "success" else 0xef4444
    fields = []

    # æ–°ã—ã„é‡ã¿ã‚’èª­ã¿è¾¼ã¿
    if WEIGHTS_FILE.exists():
        try:
            with open(WEIGHTS_FILE, 'r', encoding='utf-8') as f:
                weights_data = json.load(f)
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é‡ã¿ã‚’è¡¨ç¤º
            agent_weights = weights_data.get("weights", {})
            for agent, weight in agent_weights.items():
                # "SpeedAgent" -> "Speed" ã«å¤‰æ›
                agent_name = agent.replace("Agent", "")
                fields.append({
                    "name": f"âš–ï¸ {agent_name}",
                    "value": f"{weight:.2%}",
                    "inline": True
                })
            
            # Train ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¡¨ç¤º
            train_metrics = weights_data.get("train_metrics", {})
            if train_metrics:
                train_years = train_metrics.get("years", [])
                train_hit_rate = train_metrics.get("hit_rate", 0)
                train_recovery = train_metrics.get("recovery_rate", 0)
                
                fields.append({
                    "name": f"ğŸ“Š Train ({', '.join(map(str, train_years))})",
                    "value": f"çš„ä¸­ç‡: {train_hit_rate:.1%}\nå›åç‡: {train_recovery:.1%}",
                    "inline": True
                })
            
            # Test ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¡¨ç¤º
            test_metrics = weights_data.get("test_metrics", {})
            if test_metrics:
                test_years = test_metrics.get("years", [])
                test_hit_rate = test_metrics.get("hit_rate", 0)
                test_recovery = test_metrics.get("recovery_rate", 0)
                
                fields.append({
                    "name": f"ğŸ“ˆ Test ({', '.join(map(str, test_years))})",
                    "value": f"çš„ä¸­ç‡: {test_hit_rate:.1%}\nå›åç‡: {test_recovery:.1%}",
                    "inline": True
                })
            
            # éå­¦ç¿’ãƒã‚§ãƒƒã‚¯
            if train_metrics and test_metrics:
                train_recovery = train_metrics.get("recovery_rate", 0)
                test_recovery = test_metrics.get("recovery_rate", 0)
                
                if test_recovery > 0:
                    overfit_ratio = train_recovery / test_recovery
                    if overfit_ratio > 2.0:
                        overfit_status = "âš ï¸ éå­¦ç¿’ã®å¯èƒ½æ€§"
                        color = 0xef4444  # èµ¤
                    elif overfit_ratio > 1.5:
                        overfit_status = "âš¡ è»½åº¦ã®éå­¦ç¿’"
                        color = 0xfbbf24  # é»„
                    else:
                        overfit_status = "âœ… è‰¯å¥½"
                    
                    fields.append({
                        "name": "ğŸ” éå­¦ç¿’ãƒã‚§ãƒƒã‚¯",
                        "value": f"{overfit_status}\n(Train/Testæ¯”: {overfit_ratio:.2f})",
                        "inline": True
                    })
            
            # æ›´æ–°æ—¥æ™‚
            updated_at = weights_data.get("updated_at", "")
            if updated_at:
                fields.append({
                    "name": "ğŸ• æ›´æ–°æ—¥æ™‚",
                    "value": updated_at,
                    "inline": True
                })

        except Exception as e:
            print(f"[WARN] é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            fields.append({
                "name": "âš ï¸ ã‚¨ãƒ©ãƒ¼",
                "value": str(e),
                "inline": False
            })

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


def notify_odds(insider_count: int = 0):
    """ã‚ªãƒƒã‚ºå–å¾—ãƒ»ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼æ¤œçŸ¥é€šçŸ¥"""
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    title = "ğŸ’¹ ã‚ªãƒƒã‚ºæ›´æ–°"
    message = f"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚ªãƒƒã‚ºã‚’å–å¾—ã—ã¾ã—ãŸã€‚"
    color = 0xfbbf24
    fields = []

    # ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ç¢ºèª
    if ALERTS_FILE.exists():
        try:
            with open(ALERTS_FILE, 'r', encoding='utf-8') as f:
                alerts_data = json.load(f)
            active_alerts = [a for a in alerts_data.get("alerts", []) if a.get("status") == "active"]

            if active_alerts:
                color = 0xef4444  # ã‚¢ãƒ©ãƒ¼ãƒˆãŒã‚ã‚Œã°èµ¤è‰²
                title = "ğŸš¨ ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆæ¤œçŸ¥ï¼"
                message = f"{len(active_alerts)}ä»¶ã®ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ¤œçŸ¥ã—ã¾ã—ãŸï¼"

                for alert in active_alerts[:3]:
                    venue = alert.get("venue", "")
                    race_num = alert.get("race_num", "")
                    horse_name = alert.get("horse_name", "")
                    odds_before = alert.get("odds_before", 0)
                    odds_after = alert.get("odds_after", 0)
                    drop_rate = alert.get("drop_rate", 0)

                    fields.append({
                        "name": f"âš ï¸ {venue} {race_num}R",
                        "value": f"{horse_name}\n{odds_before:.1f} â†’ {odds_after:.1f} ({drop_rate*100:.1f}%â†“)",
                        "inline": True
                    })

        except Exception as e:
            print(f"[WARN] ã‚¢ãƒ©ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


def notify_historical(status: str = "success"):
    """éå»ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†é€šçŸ¥"""
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    title = "ğŸ“š éå»ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†"
    message = "éå»ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬å–å¾—ãŒå®Œäº†ã—ã¾ã—ãŸã€‚"
    color = 0x06b6d4 if status == "success" else 0xef4444
    fields = []

    # ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµ±è¨ˆã‚’å–å¾—
    archive_dir = DATA_DIR / "archive"
    if archive_dir.exists():
        try:
            years = [d.name for d in archive_dir.iterdir() if d.is_dir() and d.name.isdigit()]
            if years:
                fields.append({
                    "name": "ğŸ“… å–å¾—å¹´",
                    "value": ", ".join(sorted(years)),
                    "inline": True
                })
        except Exception:
            pass

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


def notify_error(error_type: str, error_message: str):
    """ã‚¨ãƒ©ãƒ¼é€šçŸ¥"""
    notifier = Notifier()

    if not notifier.available_platforms:
        print("[INFO] é€šçŸ¥ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return

    title = f"âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {error_type}"
    message = error_message
    color = 0xef4444
    fields = [
        {"name": "ğŸ• ç™ºç”Ÿæ™‚åˆ»", "value": datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "inline": True}
    ]

    results = notifier.send_all(title, message, color, fields)
    print(f"[INFO] é€šçŸ¥é€ä¿¡çµæœ: {results}")


# --- ãƒ¡ã‚¤ãƒ³ ---

def main():
    """ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã«åŸºã¥ã„ã¦é€šçŸ¥ã‚’é€ä¿¡"""
    import argparse

    parser = argparse.ArgumentParser(description="UMA-Logic PRO é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ")
    parser.add_argument("--type", choices=["predictions", "results", "optimize", "odds", "historical", "error"],
                        required=True, help="é€šçŸ¥ã‚¿ã‚¤ãƒ—")
    parser.add_argument("--status", default="success", help="ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆsuccess/failureï¼‰")
    parser.add_argument("--error-message", default="", help="ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆtypeãŒerrorã®å ´åˆï¼‰")

    args = parser.parse_args()

    if args.type == "predictions":
        notify_predictions(args.status)
    elif args.type == "results":
        notify_results(args.status)
    elif args.type == "optimize":
        notify_optimize(args.status)
    elif args.type == "odds":
        notify_odds()
    elif args.type == "historical":
        notify_historical(args.status)
    elif args.type == "error":
        notify_error("Unknown", args.error_message)


if __name__ == "__main__":
    main()

================================================================================
[3] app_commercial.py - Streamlit UI
================================================================================
# app_commercial.py
# UMA-Logic PRO - å•†ç”¨ã‚°ãƒ¬ãƒ¼ãƒ‰å®Œå…¨ç‰ˆUI
# å®Œå…¨ç‰ˆï¼ˆFull Codeï¼‰- ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã§å‹•ä½œ
# ãƒ¬ãƒ¼ã‚¹ç•ªå·æ˜‡é †ã‚½ãƒ¼ãƒˆå¯¾å¿œ + éšå±¤å‹æ¤œç´¢UIçµ±åˆ
# weights.json è‡ªå‹•é©ç”¨æ©Ÿèƒ½è¿½åŠ 

import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
from pathlib import Path
import sys

# scriptsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
sys.path.insert(0, str(Path(__file__).parent / "scripts"))

# Plotlyã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
try:
    import plotly.graph_objects as go
    import plotly.express as px
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

# AgGridã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
try:
    from st_aggrid import AgGrid, GridOptionsBuilder
    AGGRID_AVAILABLE = True
except ImportError:
    AGGRID_AVAILABLE = False

# --- ãƒšãƒ¼ã‚¸è¨­å®š ---
st.set_page_config(
    page_title="UMA-Logic PRO",
    page_icon="ğŸ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- å®šæ•° ---
DATA_DIR = Path("data")
DATA_DIR.mkdir(parents=True, exist_ok=True)
ARCHIVE_DIR = DATA_DIR / "archive"
ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
MODELS_DIR = DATA_DIR / "models"
MODELS_DIR.mkdir(parents=True, exist_ok=True)
PREDICTIONS_PREFIX = "predictions_"
RESULTS_PREFIX = "results_"
ALERTS_FILE = DATA_DIR / "insider_alerts.json"
HISTORY_FILE = DATA_DIR / "history.json"
INDEX_FILE = ARCHIVE_DIR / "index.json"
WEIGHTS_FILE = MODELS_DIR / "weights.json"

# æ›œæ—¥ã®æ—¥æœ¬èªè¡¨è¨˜
WEEKDAY_JP = ["æœˆ", "ç«", "æ°´", "æœ¨", "é‡‘", "åœŸ", "æ—¥"]

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é‡ã¿
DEFAULT_WEIGHTS = {
    "SpeedAgent": 0.35,
    "AdaptabilityAgent": 0.35,
    "PedigreeFormAgent": 0.30
}

# æœ‰åç¨®ç‰¡é¦¬ã®ã‚¹ã‚³ã‚¢è£œæ­£
SIRE_BONUS = {
    "ãƒ‡ã‚£ãƒ¼ãƒ—ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ": 15,
    "ã‚­ãƒ³ã‚°ã‚«ãƒ¡ãƒãƒ¡ãƒ": 12,
    "ãƒ­ãƒ¼ãƒ‰ã‚«ãƒŠãƒ­ã‚¢": 12,
    "ãƒãƒ¼ãƒ„ã‚¯ãƒ©ã‚¤": 10,
    "ã‚¨ãƒ”ãƒ•ã‚¡ãƒã‚¤ã‚¢": 10,
    "ãƒ‰ã‚¥ãƒ©ãƒ¡ãƒ³ãƒ†": 10,
    "ã‚­ã‚¿ã‚µãƒ³ãƒ–ãƒ©ãƒƒã‚¯": 10,
    "ãƒ¢ãƒ¼ãƒªã‚¹": 8,
    "ã‚ªãƒ«ãƒ•ã‚§ãƒ¼ãƒ´ãƒ«": 8,
    "ã‚´ãƒ¼ãƒ«ãƒ‰ã‚·ãƒƒãƒ—": 5,
}

# ãƒˆãƒƒãƒ—é¨æ‰‹
TOP_JOCKEYS = ["ãƒ«ãƒ¡ãƒ¼ãƒ«", "å·ç”°å°†é›…", "æˆ¸å´åœ­å¤ª", "æ¨ªå±±æ­¦å²", "ç¦æ°¸ç¥ä¸€", "æ­¦è±Š"]

# --- CSSã‚¹ã‚¿ã‚¤ãƒ« ---
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');

    html, body, [class*="st-"], .stApp {
        font-family: 'Noto Sans JP', sans-serif;
        background-color: #0e1117;
    }

    .main-header {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        padding: 1.5rem;
        border-radius: 10px;
        margin-bottom: 1.5rem;
        border-left: 4px solid #e94560;
    }

    .main-header h1 {
        color: #ffffff;
        margin: 0;
        font-size: 2rem;
    }

    .main-header p {
        color: #a0a0a0;
        margin: 0.5rem 0 0 0;
    }

    .race-card {
        background: linear-gradient(145deg, #1a1a2e, #16213e);
        border-radius: 12px;
        padding: 1.2rem;
        margin-bottom: 1rem;
        border: 1px solid #2a2a4a;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .race-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(233, 69, 96, 0.15);
    }

    .race-title {
        color: #e94560;
        font-size: 1.1rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
    }

    .race-info {
        color: #a0a0a0;
        font-size: 0.85rem;
    }

    .horse-row {
        display: flex;
        align-items: center;
        padding: 0.5rem 0;
        border-bottom: 1px solid #2a2a4a;
    }

    .horse-row:last-child {
        border-bottom: none;
    }

    .horse-number {
        background: #e94560;
        color: white;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        margin-right: 0.8rem;
        font-size: 0.9rem;
    }

    .horse-name {
        color: #ffffff;
        font-weight: 600;
        flex: 1;
    }

    .horse-odds {
        color: #4ade80;
        font-weight: 600;
    }

    .rank-badge {
        padding: 0.2rem 0.6rem;
        border-radius: 4px;
        font-weight: 700;
        font-size: 0.8rem;
        margin-right: 0.5rem;
    }

    .rank-s-plus {
        background: linear-gradient(135deg, #ffd700, #ffaa00);
        color: #000;
    }

    .rank-s {
        background: linear-gradient(135deg, #e94560, #ff6b6b);
        color: #fff;
    }

    .rank-a {
        background: linear-gradient(135deg, #4ade80, #22c55e);
        color: #000;
    }

    .rank-b {
        background: #3b82f6;
        color: #fff;
    }

    .rank-c {
        background: #6b7280;
        color: #fff;
    }

    .insider-alert {
        background: linear-gradient(135deg, #ff6b6b, #e94560);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }

    .metric-card {
        background: linear-gradient(145deg, #1a1a2e, #16213e);
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        border: 1px solid #2a2a4a;
    }

    .metric-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: #4ade80;
    }

    .metric-label {
        color: #a0a0a0;
        font-size: 0.85rem;
    }

    .payout-table {
        width: 100%;
        border-collapse: collapse;
    }

    .payout-table th, .payout-table td {
        padding: 0.5rem;
        text-align: left;
        border-bottom: 1px solid #2a2a4a;
    }

    .payout-table th {
        color: #a0a0a0;
        font-weight: 600;
    }

    .payout-table td {
        color: #ffffff;
    }

    .payout-amount {
        color: #4ade80;
        font-weight: 700;
    }

    .venue-button {
        background: #2a2a4a;
        color: #ffffff;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        margin-right: 0.5rem;
        cursor: pointer;
        transition: background 0.2s;
    }

    .venue-button:hover {
        background: #e94560;
    }

    .venue-button.active {
        background: #e94560;
    }

    .ai-weights-card {
        background: linear-gradient(145deg, #1a1a2e, #16213e);
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
        border: 1px solid #4ade80;
    }

    .ai-weights-title {
        color: #4ade80;
        font-size: 1rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
    }

    .weight-bar {
        height: 8px;
        background: #2a2a4a;
        border-radius: 4px;
        margin: 0.3rem 0;
        overflow: hidden;
    }

    .weight-fill {
        height: 100%;
        border-radius: 4px;
    }

    .weight-speed {
        background: linear-gradient(90deg, #e94560, #ff6b6b);
    }

    .weight-adapt {
        background: linear-gradient(90deg, #3b82f6, #60a5fa);
    }

    .weight-pedigree {
        background: linear-gradient(90deg, #4ade80, #22c55e);
    }
</style>
""", unsafe_allow_html=True)


# --- AIé‡ã¿èª­ã¿è¾¼ã¿é–¢æ•° ---

@st.cache_data(ttl=300)  # 5åˆ†é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
def load_ai_weights() -> dict:
    """weights.json ã‹ã‚‰æœ€æ–°ã®AIé‡ã¿ã‚’èª­ã¿è¾¼ã¿"""
    if WEIGHTS_FILE.exists():
        try:
            with open(WEIGHTS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data
        except Exception as e:
            st.warning(f"AIé‡ã¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
    return {
        "weights": DEFAULT_WEIGHTS.copy(),
        "metrics": {},
        "train_metrics": {},
        "test_metrics": {},
        "updated_at": ""
    }


def get_agent_weights() -> dict:
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé‡ã¿ã‚’å–å¾—"""
    data = load_ai_weights()
    return data.get("weights", DEFAULT_WEIGHTS.copy())


# --- ã‚¹ã‚³ã‚¢è¨ˆç®—é–¢æ•°ï¼ˆã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ï¼‰ ---

def calculate_speed_score(horse: dict, race: dict, weight: float = 0.35) -> float:
    """ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
    score = 50.0
    
    odds = float(horse.get("ã‚ªãƒƒã‚º", horse.get("odds", 0)) or 0)
    popularity = int(horse.get("äººæ°—", horse.get("popularity", 0)) or 0)
    gate_num = int(horse.get("æ ç•ª", horse.get("gate_num", 0)) or 0)
    distance = int(race.get("distance", 0) or 0)
    
    # ã‚ªãƒƒã‚ºãŒä½ã„ï¼ˆäººæ°—ãŒã‚ã‚‹ï¼‰ã»ã©é«˜ã‚¹ã‚³ã‚¢
    if odds > 0:
        if odds < 2.0:
            score += 30
        elif odds < 5.0:
            score += 20
        elif odds < 10.0:
            score += 10
        elif odds < 20.0:
            score += 0
        else:
            score -= 10
    
    # äººæ°—é †
    if popularity > 0:
        if popularity <= 3:
            score += 15
        elif popularity <= 6:
            score += 5
        else:
            score -= 5
    
    # è·é›¢é©æ€§ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    if distance > 0:
        if distance <= 1400:
            # çŸ­è·é›¢ã¯å†…æ æœ‰åˆ©
            if gate_num <= 4:
                score += 5
        elif distance >= 2000:
            # é•·è·é›¢ã¯å·®ã—é¦¬æœ‰åˆ©ï¼ˆäººæ°—è–„ã§ã‚‚ï¼‰
            if popularity > 5 and odds < 30:
                score += 5
    
    return max(0, min(100, score)) * weight


def calculate_adaptability_score(horse: dict, race: dict, weight: float = 0.35) -> float:
    """é©å¿œæ€§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
    score = 50.0
    
    gate_num = int(horse.get("æ ç•ª", horse.get("gate_num", 0)) or 0)
    horse_weight = float(horse.get("é¦¬ä½“é‡", horse.get("weight", 0)) or 0)
    weight_diff = float(horse.get("å¢—æ¸›", horse.get("weight_diff", 0)) or 0)
    distance = int(race.get("distance", 0) or 0)
    track_condition = race.get("track_condition", "")
    
    # æ é †è©•ä¾¡
    if distance > 0 and gate_num > 0:
        if distance <= 1400:
            if gate_num <= 3:
                score += 15
            elif gate_num <= 5:
                score += 5
            elif gate_num >= 7:
                score -= 5
        elif distance <= 1800:
            pass
        else:
            if gate_num >= 7:
                score -= 10
    
    # é¦¬å ´çŠ¶æ…‹
    if track_condition in ["é‡", "ä¸è‰¯"]:
        if horse_weight >= 500:
            score += 10
        elif horse_weight <= 440:
            score -= 5
    
    # é¦¬ä½“é‡å¢—æ¸›
    if weight_diff != 0:
        if abs(weight_diff) > 20:
            score -= 10
        elif -10 <= weight_diff <= 10:
            score += 5
    
    return max(0, min(100, score)) * weight


def calculate_pedigree_score(horse: dict, race: dict, weight: float = 0.30) -> float:
    """è¡€çµ±ãƒ»èª¿å­ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
    score = 50.0
    
    father = horse.get("çˆ¶", horse.get("father", ""))
    jockey = horse.get("é¨æ‰‹", horse.get("jockey", ""))
    odds = float(horse.get("ã‚ªãƒƒã‚º", horse.get("odds", 0)) or 0)
    
    # è¡€çµ±è©•ä¾¡
    if father:
        bonus = SIRE_BONUS.get(father, 0)
        score += bonus
    
    # é¨æ‰‹è©•ä¾¡
    if jockey in TOP_JOCKEYS:
        score += 10
    
    return max(0, min(100, score)) * weight


def calculate_uma_index(horse: dict, race: dict) -> float:
    """
    UMAæŒ‡æ•°ã‚’è¨ˆç®—ï¼ˆ3ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ï¼‰
    weights.json ã®é‡ã¿ã‚’è‡ªå‹•é©ç”¨
    """
    weights = get_agent_weights()
    
    speed_weight = weights.get("SpeedAgent", 0.35)
    adapt_weight = weights.get("AdaptabilityAgent", 0.35)
    pedigree_weight = weights.get("PedigreeFormAgent", 0.30)
    
    # å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
    speed_score = calculate_speed_score(horse, race, speed_weight)
    adapt_score = calculate_adaptability_score(horse, race, adapt_weight)
    pedigree_score = calculate_pedigree_score(horse, race, pedigree_weight)
    
    # çµ±åˆã‚¹ã‚³ã‚¢
    total_score = speed_score + adapt_score + pedigree_score
    
    return total_score


def calculate_expected_value(uma_index: float, odds: float) -> float:
    """æœŸå¾…å€¤ã‚’è¨ˆç®—"""
    if odds <= 0:
        return 0
    
    # UMAæŒ‡æ•°ã‚’å‹ç‡ã«å¤‰æ›ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    # æŒ‡æ•°70ä»¥ä¸Š â†’ å‹ç‡ç´„25%
    # æŒ‡æ•°60ä»¥ä¸Š â†’ å‹ç‡ç´„15%
    # æŒ‡æ•°50ä»¥ä¸Š â†’ å‹ç‡ç´„10%
    if uma_index >= 70:
        win_prob = 0.25
    elif uma_index >= 60:
        win_prob = 0.15
    elif uma_index >= 50:
        win_prob = 0.10
    else:
        win_prob = 0.05
    
    return win_prob * odds


def get_rank_from_score(score: float) -> str:
    """ã‚¹ã‚³ã‚¢ã‹ã‚‰ãƒ©ãƒ³ã‚¯ã‚’æ±ºå®š"""
    if score >= 75:
        return "S+"
    elif score >= 65:
        return "S"
    elif score >= 55:
        return "A"
    elif score >= 45:
        return "B"
    else:
        return "C"


# --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---

def load_json_file(file_path: Path) -> dict:
    """JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"""
    if file_path.exists():
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            st.error(f"ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
    return {}


def load_predictions(date_str: str = None) -> dict:
    """äºˆæƒ³ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿"""
    if date_str is None:
        date_str = datetime.now().strftime("%Y%m%d")
    file_path = DATA_DIR / f"{PREDICTIONS_PREFIX}{date_str}.json"
    return load_json_file(file_path)


def load_results(date_str: str = None) -> dict:
    """çµæœãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¯¾å¿œï¼‰"""
    if date_str is None:
        date_str = datetime.now().strftime("%Y%m%d")

    # ã¾ãšã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‹ã‚‰æ¢ã™
    year = date_str[:4]
    month = date_str[4:6]
    day = date_str[6:8]
    archive_path = ARCHIVE_DIR / year / month / day / f"{RESULTS_PREFIX}{date_str}.json"

    if archive_path.exists():
        return load_json_file(archive_path)

    # ãªã‘ã‚Œã°data/ã‹ã‚‰æ¢ã™
    file_path = DATA_DIR / f"{RESULTS_PREFIX}{date_str}.json"
    return load_json_file(file_path)


def load_insider_alerts() -> dict:
    """ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿"""
    return load_json_file(ALERTS_FILE)


def load_history() -> list:
    """çš„ä¸­å±¥æ­´ã‚’èª­ã¿è¾¼ã¿"""
    data = load_json_file(HISTORY_FILE)
    return data.get("history", [])


def load_archive_index() -> dict:
    """ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª­ã¿è¾¼ã¿"""
    return load_json_file(INDEX_FILE)


def get_available_dates() -> list:
    """åˆ©ç”¨å¯èƒ½ãªæ—¥ä»˜ãƒªã‚¹ãƒˆã‚’å–å¾—"""
    dates = set()

    # data/ã‹ã‚‰å–å¾—
    for f in DATA_DIR.glob(f"{RESULTS_PREFIX}*.json"):
        match = f.stem.replace(RESULTS_PREFIX, "")
        if len(match) == 8 and match.isdigit():
            dates.add(match)

    # ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‹ã‚‰å–å¾—
    if ARCHIVE_DIR.exists():
        for year_dir in ARCHIVE_DIR.iterdir():
            if not year_dir.is_dir() or not year_dir.name.isdigit():
                continue
            for month_dir in year_dir.iterdir():
                if not month_dir.is_dir() or not month_dir.name.isdigit():
                    continue
                for day_dir in month_dir.iterdir():
                    if not day_dir.is_dir() or not day_dir.name.isdigit():
                        continue
                    date_str = f"{year_dir.name}{month_dir.name}{day_dir.name}"
                    dates.add(date_str)

    return sorted(dates, reverse=True)


def format_date_jp(date_str: str) -> str:
    """æ—¥ä»˜ã‚’æ—¥æœ¬èªå½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
    try:
        dt = datetime.strptime(date_str, "%Y%m%d")
        weekday = WEEKDAY_JP[dt.weekday()]
        return f"{dt.month}æœˆ{dt.day}æ—¥ ({weekday})"
    except Exception:
        return date_str


def get_rank_badge_html(rank: str) -> str:
    """ãƒ©ãƒ³ã‚¯ãƒãƒƒã‚¸ã®HTMLã‚’ç”Ÿæˆ"""
    rank_classes = {
        "S+": "rank-s-plus",
        "S": "rank-s",
        "A": "rank-a",
        "B": "rank-b",
        "C": "rank-c",
        "D": "rank-c"
    }
    css_class = rank_classes.get(rank, "rank-c")
    return f'<span class="rank-badge {css_class}">{rank}</span>'


def sort_races_by_number(races: list) -> list:
    """ãƒ¬ãƒ¼ã‚¹ã‚’ç•ªå·é †ã«ã‚½ãƒ¼ãƒˆï¼ˆ1Râ†’12Rï¼‰"""
    def get_race_num(race):
        race_num = race.get("race_num", 0)
        if isinstance(race_num, str):
            # "1R" â†’ 1 ã®ã‚ˆã†ã«å¤‰æ›
            num_str = ''.join(filter(str.isdigit, race_num))
            return int(num_str) if num_str else 0
        return race_num if race_num else 0

    return sorted(races, key=get_race_num)


# --- ãƒ¡ã‚¤ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼ ---
st.markdown("""
<div class="main-header">
    <h1>ğŸ UMA-Logic PRO</h1>
    <p>AIç«¶é¦¬äºˆæƒ³ã‚·ã‚¹ãƒ†ãƒ  - å•†ç”¨ã‚°ãƒ¬ãƒ¼ãƒ‰å®Œå…¨ç‰ˆï¼ˆã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«å­¦ç¿’å¯¾å¿œï¼‰</p>
</div>
""", unsafe_allow_html=True)


# --- ã‚µã‚¤ãƒ‰ãƒãƒ¼ ---
with st.sidebar:
    st.markdown("### âš™ï¸ è¨­å®š")

    # è³‡é‡‘è¨­å®š
    bankroll = st.number_input(
        "ğŸ’° ç·è³‡é‡‘ (å††)",
        min_value=10000,
        max_value=10000000,
        value=100000,
        step=10000
    )

    # ã‚±ãƒªãƒ¼åŸºæº–ãƒ¢ãƒ¼ãƒ‰
    kelly_mode = st.selectbox(
        "ğŸ“Š æŠ•è³‡ãƒ¢ãƒ¼ãƒ‰",
        ["ãƒãƒ¼ãƒ•ã‚±ãƒªãƒ¼ï¼ˆå®‰å…¨ï¼‰", "ãƒ•ãƒ«ã‚±ãƒªãƒ¼ï¼ˆæ¨™æº–ï¼‰", "ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–ï¼ˆç©æ¥µçš„ï¼‰"]
    )

    st.markdown("---")

    # AIé‡ã¿è¡¨ç¤º
    st.markdown("### ğŸ§  AIé‡ã¿ï¼ˆè‡ªå‹•é©ç”¨ï¼‰")
    
    ai_data = load_ai_weights()
    weights = ai_data.get("weights", DEFAULT_WEIGHTS)
    metrics = ai_data.get("metrics", {})
    test_metrics = ai_data.get("test_metrics", {})
    updated_at = ai_data.get("updated_at", "æœªæ›´æ–°")
    
    # é‡ã¿ãƒãƒ¼è¡¨ç¤º
    speed_pct = weights.get("SpeedAgent", 0.35) * 100
    adapt_pct = weights.get("AdaptabilityAgent", 0.35) * 100
    pedigree_pct = weights.get("PedigreeFormAgent", 0.30) * 100
    
    st.markdown(f"""
    <div class="ai-weights-card">
        <div class="ai-weights-title">ğŸ”¥ Speed: {speed_pct:.0f}%</div>
        <div class="weight-bar"><div class="weight-fill weight-speed" style="width: {speed_pct}%;"></div></div>
        <div class="ai-weights-title">ğŸ¯ Adapt: {adapt_pct:.0f}%</div>
        <div class="weight-bar"><div class="weight-fill weight-adapt" style="width: {adapt_pct}%;"></div></div>
        <div class="ai-weights-title">ğŸ§¬ Pedigree: {pedigree_pct:.0f}%</div>
        <div class="weight-bar"><div class="weight-fill weight-pedigree" style="width: {pedigree_pct}%;"></div></div>
    </div>
    """, unsafe_allow_html=True)
    
    # ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®æˆç¸¾
    if test_metrics:
        test_hit_rate = test_metrics.get("hit_rate", 0) * 100
        test_recovery = test_metrics.get("recovery_rate", 0) * 100
        st.markdown(f"**ãƒ†ã‚¹ãƒˆæˆç¸¾**: çš„ä¸­ç‡ {test_hit_rate:.1f}% / å›åç‡ {test_recovery:.1f}%")
    elif metrics:
        hit_rate = metrics.get("hit_rate", 0) * 100
        recovery = metrics.get("recovery_rate", 0) * 100
        st.markdown(f"**æˆç¸¾**: çš„ä¸­ç‡ {hit_rate:.1f}% / å›åç‡ {recovery:.1f}%")
    
    st.markdown(f"<small>æ›´æ–°: {updated_at}</small>", unsafe_allow_html=True)
    
    # é‡ã¿å†èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³
    if st.button("ğŸ”„ é‡ã¿å†èª­ã¿è¾¼ã¿"):
        st.cache_data.clear()
        st.rerun()

    st.markdown("---")

    # ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹
    st.markdown("### ğŸ“ˆ ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹")

    # åˆ©ç”¨å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿æ•°
    available_dates = get_available_dates()
    st.metric("ğŸ“… ãƒ‡ãƒ¼ã‚¿æ—¥æ•°", f"{len(available_dates)}æ—¥")

    # æœ€çµ‚æ›´æ–°
    if available_dates:
        latest_date = available_dates[0]
        st.metric("ğŸ• æœ€æ–°ãƒ‡ãƒ¼ã‚¿", format_date_jp(latest_date))


# --- ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ– ---
tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
    "ğŸ¯ æœ¬æ—¥ã®äºˆæƒ³",
    "ğŸ“Š ãƒ¬ãƒ¼ã‚¹çµæœ",
    "ğŸ‰ çš„ä¸­å®Ÿç¸¾",
    "ğŸ“ˆ åæ”¯ãƒ¬ãƒãƒ¼ãƒˆ",
    "ğŸ’° è³‡é‡‘é…åˆ†",
    "ğŸ§  AIå­¦ç¿’çŠ¶æ³",
    "âš™ï¸ ã‚·ã‚¹ãƒ†ãƒ "
])


# === ã‚¿ãƒ–1: æœ¬æ—¥ã®äºˆæƒ³ ===
with tab1:
    st.header("ğŸ¯ æœ¬æ—¥ã®äºˆæƒ³")

    # ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
    alerts_data = load_insider_alerts()
    active_alerts = [a for a in alerts_data.get("alerts", [])
                     if a.get("status") == "active"]

    if active_alerts:
        st.markdown("### ğŸš¨ ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆ")
        for alert in active_alerts[:3]:
            st.markdown(f"""
            <div class="insider-alert">
                <strong>âš¡ {alert.get('venue', '')} {alert.get('race_num', '')}R - {alert.get('horse_name', '')}</strong><br>
                ã‚ªãƒƒã‚ºæ€¥è½æ¤œçŸ¥: {alert.get('odds_before', 0):.1f} â†’ {alert.get('odds_after', 0):.1f}
                ï¼ˆ{alert.get('drop_rate', 0)*100:.1f}%ä½ä¸‹ï¼‰<br>
                <small>æ¤œå‡ºæ™‚åˆ»: {alert.get('detected_at', '')}</small>
            </div>
            """, unsafe_allow_html=True)

    # äºˆæƒ³ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    today_str = datetime.now().strftime("%Y%m%d")
    predictions = load_predictions(today_str)

    if predictions and predictions.get("races"):
        races = predictions.get("races", [])
        races = sort_races_by_number(races)  # ãƒ¬ãƒ¼ã‚¹ç•ªå·é †ã«ã‚½ãƒ¼ãƒˆ

        # ç«¶é¦¬å ´ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        venues = list(set(r.get("venue", "") for r in races))
        venues = sorted(venues)

        if venues:
            selected_venue = st.selectbox("ğŸŸï¸ ç«¶é¦¬å ´ã‚’é¸æŠ", venues)

            venue_races = [r for r in races if r.get("venue") == selected_venue]
            venue_races = sort_races_by_number(venue_races)

            for race in venue_races:
                race_num = race.get("race_num", 0)
                race_name = race.get("race_name", "")
                distance = race.get("distance", 0)
                track_type = race.get("track_type", "")

                with st.expander(f"ğŸ‡ {race_num}R {race_name} ({track_type}{distance}m)", expanded=False):
                    horses = race.get("horses", []) or race.get("predictions", [])

                    if horses:
                        # UMAæŒ‡æ•°ã‚’å†è¨ˆç®—ï¼ˆæœ€æ–°ã®é‡ã¿ã‚’é©ç”¨ï¼‰
                        for horse in horses:
                            uma_index = calculate_uma_index(horse, race)
                            horse["uma_index"] = uma_index
                            horse["rank"] = get_rank_from_score(uma_index)
                            
                            odds = float(horse.get("ã‚ªãƒƒã‚º", horse.get("odds", 0)) or 0)
                            horse["expected_value"] = calculate_expected_value(uma_index, odds)
                        
                        # UMAæŒ‡æ•°ã§ã‚½ãƒ¼ãƒˆ
                        horses = sorted(horses, key=lambda x: x.get("uma_index", 0), reverse=True)

                        for i, horse in enumerate(horses[:5]):  # ä¸Šä½5é ­è¡¨ç¤º
                            umaban = horse.get("umaban", horse.get("é¦¬ç•ª", ""))
                            name = horse.get("horse_name", horse.get("é¦¬å", ""))
                            odds = horse.get("odds", horse.get("ã‚ªãƒƒã‚º", 0))
                            uma_index = horse.get("uma_index", 0)
                            rank = horse.get("rank", "C")
                            ev = horse.get("expected_value", 0)

                            # å°ã‚’æ±ºå®š
                            marks = ["â—", "â—‹", "â–²", "â–³", "â˜†"]
                            mark = marks[i] if i < len(marks) else ""

                            col1, col2, col3, col4, col5, col6 = st.columns([1, 1, 3, 2, 2, 1])
                            with col1:
                                st.markdown(f"**{mark}**")
                            with col2:
                                st.markdown(f"**{umaban}**")
                            with col3:
                                st.markdown(f"{name}")
                            with col4:
                                if uma_index > 0:
                                    st.markdown(f"æŒ‡æ•°: **{uma_index:.1f}**")
                            with col5:
                                if odds > 0:
                                    st.markdown(f"ã‚ªãƒƒã‚º: **{odds:.1f}**")
                            with col6:
                                st.markdown(get_rank_badge_html(rank), unsafe_allow_html=True)
                    else:
                        st.info("å‡ºé¦¬ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
    else:
        st.info("ğŸ“­ æœ¬æ—¥ã®äºˆæƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚åœŸæ—¥ã®æœã«è‡ªå‹•æ›´æ–°ã•ã‚Œã¾ã™ã€‚")


# === ã‚¿ãƒ–2: ãƒ¬ãƒ¼ã‚¹çµæœï¼ˆéšå±¤å‹æ¤œç´¢UIï¼‰ ===
with tab2:
    st.header("ğŸ“Š ãƒ¬ãƒ¼ã‚¹çµæœ")

    # åˆ©ç”¨å¯èƒ½ãªæ—¥ä»˜ã‚’å–å¾—
    available_dates = get_available_dates()

    if not available_dates:
        st.info("ğŸ“­ ãƒ¬ãƒ¼ã‚¹çµæœãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
    else:
        # å¹´ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        dates_by_year = {}
        for date_str in available_dates:
            year = date_str[:4]
            if year not in dates_by_year:
                dates_by_year[year] = []
            dates_by_year[year].append(date_str)

        # éšå±¤å‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        filter_col1, filter_col2 = st.columns(2)

        with filter_col1:
            years = sorted(dates_by_year.keys(), reverse=True)
            selected_year = st.selectbox("ğŸ“… å¹´ã‚’é¸æŠ", years, key="result_year")

        with filter_col2:
            year_dates = dates_by_year.get(selected_year, [])
            date_options = [(d, format_date_jp(d)) for d in year_dates]

            if date_options:
                selected_date_idx = st.selectbox(
                    "ğŸ“† é–‹å‚¬æ—¥ã‚’é¸æŠ",
                    range(len(date_options)),
                    format_func=lambda x: date_options[x][1],
                    key="result_date"
                )
                selected_date = date_options[selected_date_idx][0]
            else:
                selected_date = None

        if selected_date:
            # çµæœãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
            results_data = load_results(selected_date)

            if results_data and results_data.get("races"):
                races = results_data.get("races", [])
                races = sort_races_by_number(races)  # ãƒ¬ãƒ¼ã‚¹ç•ªå·é †ã«ã‚½ãƒ¼ãƒˆ

                # ç«¶é¦¬å ´ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                venues = list(set(r.get("venue", "") for r in races if r.get("venue")))
                venues = sorted(venues)

                if venues:
                    # ç«¶é¦¬å ´ã‚¿ãƒ–
                    venue_tabs = st.tabs(venues)

                    for venue_tab, venue in zip(venue_tabs, venues):
                        with venue_tab:
                            venue_races = [r for r in races if r.get("venue") == venue]
                            venue_races = sort_races_by_number(venue_races)

                            for race in venue_races:
                                race_num = race.get("race_num", 0)
                                race_name = race.get("race_name", "")

                                # ãƒ¬ãƒ¼ã‚¹ã‚«ãƒ¼ãƒ‰
                                st.markdown(f"""
                                <div class="race-card">
                                    <div class="race-title">{race_num}R {race_name}</div>
                                    <div class="race-info">{venue} / {race.get('distance', '')}m / {race.get('track_type', '')}</div>
                                </div>
                                """, unsafe_allow_html=True)

                                with st.expander(f"ğŸ“‹ è©³ç´°ã‚’è¦‹ã‚‹", expanded=False):
                                    # ç€é †è¡¨
                                    st.markdown("#### ğŸ† ç€é †")
                                    top3 = race.get("top3", [])
                                    all_results = race.get("all_results", top3)

                                    if all_results:
                                        result_df = pd.DataFrame(all_results)

                                        # ã‚«ãƒ©ãƒ åã‚’æ—¥æœ¬èªã«
                                        column_mapping = {
                                            "ç€é †": "ç€é †",
                                            "rank": "ç€é †",
                                            "é¦¬ç•ª": "é¦¬ç•ª",
                                            "umaban": "é¦¬ç•ª",
                                            "é¦¬å": "é¦¬å",
                                            "horse_name": "é¦¬å",
                                            "é¨æ‰‹": "é¨æ‰‹",
                                            "jockey": "é¨æ‰‹",
                                            "ã‚¿ã‚¤ãƒ ": "ã‚¿ã‚¤ãƒ ",
                                            "time": "ã‚¿ã‚¤ãƒ ",
                                            "ä¸ŠãŒã‚Š3F": "ä¸ŠãŒã‚Š3F",
                                            "last_3f": "ä¸ŠãŒã‚Š3F",
                                            "ã‚ªãƒƒã‚º": "ã‚ªãƒƒã‚º",
                                            "odds": "ã‚ªãƒƒã‚º"
                                        }

                                        result_df = result_df.rename(columns=column_mapping)

                                        # è¡¨ç¤ºã™ã‚‹ã‚«ãƒ©ãƒ ã‚’é¸æŠ
                                        display_cols = ["ç€é †", "é¦¬ç•ª", "é¦¬å", "é¨æ‰‹", "ã‚¿ã‚¤ãƒ ", "ä¸ŠãŒã‚Š3F", "ã‚ªãƒƒã‚º"]
                                        display_cols = [c for c in display_cols if c in result_df.columns]

                                        if display_cols:
                                            st.dataframe(
                                                result_df[display_cols],
                                                use_container_width=True,
                                                hide_index=True
                                            )
                                    else:
                                        st.info("ç€é †ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")

                                    # æ‰•æˆ»é‡‘è¡¨
                                    st.markdown("#### ğŸ’° æ‰•æˆ»é‡‘")
                                    payouts = race.get("payouts", {})

                                    if payouts:
                                        # 2ã‚«ãƒ©ãƒ ã§è¡¨ç¤º
                                        payout_col1, payout_col2 = st.columns(2)

                                        payout_items = list(payouts.items())
                                        mid = len(payout_items) // 2 + len(payout_items) % 2

                                        with payout_col1:
                                            for key, value in payout_items[:mid]:
                                                if isinstance(value, dict):
                                                    # è¤‡å‹ãƒ»ãƒ¯ã‚¤ãƒ‰ãªã©è¤‡æ•°å€¤
                                                    values_str = " / ".join([f"{k}: Â¥{v:,}" for k, v in value.items()])
                                                    st.markdown(f"**{key}**: {values_str}")
                                                else:
                                                    st.markdown(f"**{key}**: Â¥{value:,}")

                                        with payout_col2:
                                            for key, value in payout_items[mid:]:
                                                if isinstance(value, dict):
                                                    values_str = " / ".join([f"{k}: Â¥{v:,}" for k, v in value.items()])
                                                    st.markdown(f"**{key}**: {values_str}")
                                                else:
                                                    st.markdown(f"**{key}**: Â¥{value:,}")
                                    else:
                                        st.info("æ‰•æˆ»é‡‘ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")

                                st.markdown("---")
                else:
                    st.warning("ç«¶é¦¬å ´æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“")
            else:
                st.warning(f"{format_date_jp(selected_date)} ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")


# === ã‚¿ãƒ–3: çš„ä¸­å®Ÿç¸¾ ===
with tab3:
    st.header("ğŸ‰ çš„ä¸­å®Ÿç¸¾")

    history = load_history()

    if history:
        # æœ€æ–°é †ã«ã‚½ãƒ¼ãƒˆ
        history = sorted(history, key=lambda x: x.get("date", ""), reverse=True)

        # çµ±è¨ˆ
        total_hits = len(history)
        total_payout = sum(h.get("payout", 0) for h in history)

        col1, col2 = st.columns(2)
        with col1:
            st.metric("ğŸ¯ ç·çš„ä¸­æ•°", f"{total_hits}å›")
        with col2:
            st.metric("ğŸ’° ç·æ‰•æˆ»é‡‘", f"Â¥{total_payout:,}")

        st.markdown("---")

        # çš„ä¸­å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«
        for hit in history[:20]:  # æœ€æ–°20ä»¶
            date = hit.get("date", "")
            venue = hit.get("venue", "")
            race_num = hit.get("race_num", "")
            bet_type = hit.get("bet_type", "")
            payout = hit.get("payout", 0)
            horse = hit.get("horse_name", "")

            st.markdown(f"""
            <div class="race-card">
                <div class="race-title">ğŸ‰ {venue} {race_num}R - {bet_type}</div>
                <div class="race-info">
                    {format_date_jp(date) if date else ''} / {horse}<br>
                    <span class="payout-amount">æ‰•æˆ»: Â¥{payout:,}</span>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.info("ğŸ“­ ã¾ã çš„ä¸­ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")


# === ã‚¿ãƒ–4: åæ”¯ãƒ¬ãƒãƒ¼ãƒˆ ===
with tab4:
    st.header("ğŸ“ˆ åæ”¯ãƒ¬ãƒãƒ¼ãƒˆ")

    history = load_history()

    if history:
        # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ åŒ–
        df = pd.DataFrame(history)

        if "date" in df.columns and "payout" in df.columns:
            # æ—¥ä»˜ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            df["date"] = pd.to_datetime(df["date"], format="%Y%m%d", errors="coerce")
            daily = df.groupby(df["date"].dt.date).agg({
                "payout": "sum",
                "bet_amount": "sum" if "bet_amount" in df.columns else "count"
            }).reset_index()

            # ç´¯ç©åæ”¯
            if "bet_amount" in daily.columns:
                daily["profit"] = daily["payout"] - daily["bet_amount"]
                daily["cumulative"] = daily["profit"].cumsum()

                # ã‚°ãƒ©ãƒ•
                if PLOTLY_AVAILABLE:
                    fig = go.Figure()
                    fig.add_trace(go.Scatter(
                        x=daily["date"],
                        y=daily["cumulative"],
                        mode="lines+markers",
                        name="ç´¯ç©åæ”¯",
                        line=dict(color="#4ade80", width=2)
                    ))
                    fig.update_layout(
                        title="ç´¯ç©åæ”¯æ¨ç§»",
                        xaxis_title="æ—¥ä»˜",
                        yaxis_title="åæ”¯ (å††)",
                        template="plotly_dark",
                        height=400
                    )
                    st.plotly_chart(fig, use_container_width=True)

            # ã‚µãƒãƒªãƒ¼
            total_bet = df["bet_amount"].sum() if "bet_amount" in df.columns else 0
            total_payout = df["payout"].sum()
            profit = total_payout - total_bet
            roi = (total_payout / total_bet * 100) if total_bet > 0 else 0

            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("ğŸ’¸ ç·æŠ•è³‡é¡", f"Â¥{total_bet:,}")
            with col2:
                st.metric("ğŸ’° ç·æ‰•æˆ»é¡", f"Â¥{total_payout:,}")
            with col3:
                st.metric("ğŸ“Š ç´”æç›Š", f"Â¥{profit:,}")
            with col4:
                st.metric("ğŸ“ˆ å›åç‡", f"{roi:.1f}%")
    else:
        st.info("ğŸ“­ ã¾ã åæ”¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")


# === ã‚¿ãƒ–5: è³‡é‡‘é…åˆ† ===
with tab5:
    st.header("ğŸ’° è³‡é‡‘é…åˆ†ï¼ˆã‚±ãƒªãƒ¼åŸºæº–ï¼‰")

    st.markdown("""
    **ã‚±ãƒªãƒ¼åŸºæº–**ã¯ã€æœŸå¾…å€¤ãŒãƒ—ãƒ©ã‚¹ã®è³­ã‘ã«å¯¾ã—ã¦ã€é•·æœŸçš„ã«è³‡é‡‘ã‚’æœ€å¤§åŒ–ã™ã‚‹æœ€é©ãªæŠ•è³‡æ¯”ç‡ã‚’ç®—å‡ºã™ã‚‹æ•°å­¦çš„æ‰‹æ³•ã§ã™ã€‚

    - **ãƒãƒ¼ãƒ•ã‚±ãƒªãƒ¼**: å®‰å…¨é‡è¦–ï¼ˆæ¨å¥¨ï¼‰
    - **ãƒ•ãƒ«ã‚±ãƒªãƒ¼**: æ¨™æº–
    - **ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–**: ç©æ¥µçš„ï¼ˆã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼æ¤œçŸ¥æ™‚ã«è‡ªå‹•åˆ‡æ›¿ï¼‰
    """)

    st.markdown("---")

    # è¨ˆç®—ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼
    st.markdown("### ğŸ“Š æŠ•è³‡é¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼")

    sim_col1, sim_col2 = st.columns(2)

    with sim_col1:
        sim_prob = st.slider("å‹ç‡ (%)", 5, 50, 20) / 100
        sim_odds = st.slider("ã‚ªãƒƒã‚º", 1.5, 30.0, 5.0, 0.5)

    with sim_col2:
        sim_bankroll = st.number_input("è³‡é‡‘ (å††)", 10000, 10000000, bankroll, 10000)

    # ã‚±ãƒªãƒ¼è¨ˆç®—
    b = sim_odds - 1
    p = sim_prob
    q = 1 - p
    kelly = (b * p - q) / b if b > 0 else 0
    kelly = max(0, kelly)

    half_kelly = kelly * 0.5
    full_kelly = kelly
    aggressive_kelly = kelly * 1.2

    st.markdown("### ğŸ“ˆ æ¨å¥¨æŠ•è³‡é¡")

    result_col1, result_col2, result_col3 = st.columns(3)

    with result_col1:
        bet_half = int(sim_bankroll * half_kelly / 100) * 100
        st.metric("ãƒãƒ¼ãƒ•ã‚±ãƒªãƒ¼", f"Â¥{bet_half:,}", f"{half_kelly*100:.2f}%")

    with result_col2:
        bet_full = int(sim_bankroll * full_kelly / 100) * 100
        st.metric("ãƒ•ãƒ«ã‚±ãƒªãƒ¼", f"Â¥{bet_full:,}", f"{full_kelly*100:.2f}%")

    with result_col3:
        bet_agg = int(sim_bankroll * aggressive_kelly / 100) * 100
        st.metric("ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–", f"Â¥{bet_agg:,}", f"{aggressive_kelly*100:.2f}%")

    # æœŸå¾…å€¤
    expected_value = sim_prob * sim_odds
    st.markdown(f"**æœŸå¾…å€¤**: {expected_value:.2f} {'âœ… ãƒ—ãƒ©ã‚¹æœŸå¾…å€¤' if expected_value > 1 else 'âŒ ãƒã‚¤ãƒŠã‚¹æœŸå¾…å€¤'}")


# === ã‚¿ãƒ–6: AIå­¦ç¿’çŠ¶æ³ ===
with tab6:
    st.header("ğŸ§  AIå­¦ç¿’çŠ¶æ³")
    
    ai_data = load_ai_weights()
    
    # --- è³‡ç”£æ¨ç§»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ---
    st.markdown("### ğŸ“ˆ è³‡ç”£æ¨ç§»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆEquity Curveï¼‰")
    
    test_metrics = ai_data.get("test_metrics", {})
    metrics = ai_data.get("metrics", {})
    
    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    sim_col1, sim_col2, sim_col3 = st.columns(3)
    with sim_col1:
        initial_capital = st.number_input("åˆæœŸè³‡é‡‘ (å††)", 10000, 10000000, 100000, 10000, key="equity_capital")
    with sim_col2:
        bet_per_race = st.number_input("1ãƒ¬ãƒ¼ã‚¹ã‚ãŸã‚ŠæŠ•è³‡é¡ (å††)", 100, 10000, 100, 100, key="equity_bet")
    with sim_col3:
        sim_races = st.number_input("ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ¼ã‚¹æ•°", 100, 10000, 1000, 100, key="equity_races")
    
    # çš„ä¸­ç‡ã¨å›åç‡ã‚’å–å¾—
    hit_rate = test_metrics.get("hit_rate", metrics.get("hit_rate", 0.2))
    recovery_rate = test_metrics.get("recovery_rate", metrics.get("recovery_rate", 0.8))
    
    if hit_rate > 0 and recovery_rate > 0:
        # å¹³å‡ã‚ªãƒƒã‚ºã‚’é€†ç®—ï¼ˆå›åç‡ = çš„ä¸­ç‡ Ã— å¹³å‡ã‚ªãƒƒã‚ºï¼‰
        avg_odds = recovery_rate / hit_rate if hit_rate > 0 else 5.0
        
        # ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        import random
        random.seed(42)  # å†ç¾æ€§ã®ãŸã‚
        
        equity_curve = [initial_capital]
        drawdowns = []
        max_equity = initial_capital
        current_equity = initial_capital
        
        consecutive_losses = 0
        max_consecutive_losses = 0
        
        for i in range(sim_races):
            # çš„ä¸­åˆ¤å®š
            if random.random() < hit_rate:
                # çš„ä¸­
                payout = int(bet_per_race * avg_odds)
                current_equity += payout - bet_per_race
                consecutive_losses = 0
            else:
                # ä¸çš„ä¸­
                current_equity -= bet_per_race
                consecutive_losses += 1
                max_consecutive_losses = max(max_consecutive_losses, consecutive_losses)
            
            # è³‡é‡‘ãŒ0ä»¥ä¸‹ã«ãªã£ãŸã‚‰çµ‚äº†
            if current_equity <= 0:
                current_equity = 0
                equity_curve.append(current_equity)
                break
            
            equity_curve.append(current_equity)
            
            # ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è¨ˆç®—
            if current_equity > max_equity:
                max_equity = current_equity
            drawdown = (max_equity - current_equity) / max_equity if max_equity > 0 else 0
            drawdowns.append(drawdown)
        
        # è³‡ç”£æ¨ç§»ã‚°ãƒ©ãƒ•
        if PLOTLY_AVAILABLE:
            fig_equity = go.Figure()
            fig_equity.add_trace(go.Scatter(
                x=list(range(len(equity_curve))),
                y=equity_curve,
                mode="lines",
                name="è³‡ç”£æ¨ç§»",
                line=dict(color="#4ade80", width=2)
            ))
            fig_equity.add_hline(y=initial_capital, line_dash="dash", line_color="#fbbf24", annotation_text="åˆæœŸè³‡é‡‘")
            fig_equity.update_layout(
                title=f"è³‡ç”£æ¨ç§»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆçš„ä¸­ç‡: {hit_rate*100:.1f}%, å›åç‡: {recovery_rate*100:.1f}%ï¼‰",
                xaxis_title="ãƒ¬ãƒ¼ã‚¹æ•°",
                yaxis_title="è³‡ç”£ (å††)",
                template="plotly_dark",
                height=400
            )
            st.plotly_chart(fig_equity, use_container_width=True)
        else:
            st.line_chart(equity_curve)
        
        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚µãƒãƒªãƒ¼
        final_equity = equity_curve[-1]
        total_profit = final_equity - initial_capital
        profit_rate = (final_equity / initial_capital - 1) * 100
        max_drawdown = max(drawdowns) * 100 if drawdowns else 0
        
        result_col1, result_col2, result_col3, result_col4 = st.columns(4)
        with result_col1:
            st.metric("æœ€çµ‚è³‡ç”£", f"Â¥{final_equity:,.0f}", f"{profit_rate:+.1f}%")
        with result_col2:
            st.metric("ç´”æç›Š", f"Â¥{total_profit:,.0f}")
        with result_col3:
            st.metric("æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³", f"{max_drawdown:.1f}%")
        with result_col4:
            st.metric("æœ€å¤§é€£æ•—æ•°", f"{max_consecutive_losses}é€£æ•—")
        
        st.markdown("---")
        
        # --- ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è§£æ ---
        st.markdown("### ğŸ“‰ ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è§£æ")
        
        if PLOTLY_AVAILABLE and drawdowns:
            fig_dd = go.Figure()
            fig_dd.add_trace(go.Scatter(
                x=list(range(len(drawdowns))),
                y=[d * 100 for d in drawdowns],
                mode="lines",
                name="ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³",
                fill="tozeroy",
                line=dict(color="#ef4444", width=1)
            ))
            fig_dd.update_layout(
                title="ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³æ¨ç§»ï¼ˆè³‡ç”£æœ€é«˜å€¤ã‹ã‚‰ã®ä¸‹è½ç‡ï¼‰",
                xaxis_title="ãƒ¬ãƒ¼ã‚¹æ•°",
                yaxis_title="ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ (%)",
                template="plotly_dark",
                height=300
            )
            st.plotly_chart(fig_dd, use_container_width=True)
        
        # ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³çµ±è¨ˆ
        st.markdown("#### ğŸ“Š ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³çµ±è¨ˆ")
        
        if drawdowns:
            avg_dd = sum(drawdowns) / len(drawdowns) * 100
            
            dd_col1, dd_col2, dd_col3 = st.columns(3)
            with dd_col1:
                st.metric("å¹³å‡ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³", f"{avg_dd:.2f}%")
            with dd_col2:
                st.metric("æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³", f"{max_drawdown:.2f}%")
            with dd_col3:
                # å›å¾©ã«å¿…è¦ãªå‹ç‡
                recovery_needed = max_drawdown / (1 - max_drawdown/100) if max_drawdown < 100 else float('inf')
                st.metric("å›å¾©ã«å¿…è¦ãªä¸Šæ˜‡ç‡", f"{recovery_needed:.2f}%")
        
        # é€£æ•—ç¢ºç‡ã®è§£èª¬
        st.markdown("#### ğŸ² é€£æ•—ç¢ºç‡ã®ç†è«–å€¤")
        
        loss_rate = 1 - hit_rate
        st.markdown(f"""
        | é€£æ•—æ•° | ç¢ºç‡ | ç™ºç”Ÿé »åº¦ï¼ˆ{sim_races}ãƒ¬ãƒ¼ã‚¹ä¸­ï¼‰ |
        |--------|------|-------------------------------|
        | 5é€£æ•— | {(loss_rate**5)*100:.2f}% | ç´„{int(sim_races * (loss_rate**5))}å› |
        | 10é€£æ•— | {(loss_rate**10)*100:.4f}% | ç´„{int(sim_races * (loss_rate**10))}å› |
        | 15é€£æ•— | {(loss_rate**15)*100:.6f}% | ç´„{int(sim_races * (loss_rate**15))}å› |
        | 20é€£æ•— | {(loss_rate**20)*100:.8f}% | ç´„{int(sim_races * (loss_rate**20))}å› |
        
        **è§£èª¬**: çš„ä¸­ç‡{hit_rate*100:.1f}%ã®å ´åˆã€{max_consecutive_losses}é€£æ•—ã¯çµ±è¨ˆçš„ã«ååˆ†èµ·ã“ã‚Šã†ã‚‹ç¯„å›²ã§ã™ã€‚
        ã‚·ã‚¹ãƒ†ãƒ ã‚’ä¿¡ã˜ã¦ç¶™ç¶šã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚
        """)
    else:
        st.warning("AIå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒãªã„ãŸã‚ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚")
    
    st.markdown("---")
    
    # åŸºæœ¬æƒ…å ±
    st.markdown("### ğŸ“Š ç¾åœ¨ã®AIé‡ã¿")
    
    weights = ai_data.get("weights", DEFAULT_WEIGHTS)
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("ğŸ”¥ SpeedAgent", f"{weights.get('SpeedAgent', 0.35)*100:.0f}%")
    with col2:
        st.metric("ğŸ¯ AdaptabilityAgent", f"{weights.get('AdaptabilityAgent', 0.35)*100:.0f}%")
    with col3:
        st.metric("ğŸ§¬ PedigreeFormAgent", f"{weights.get('PedigreeFormAgent', 0.30)*100:.0f}%")
    
    st.markdown("---")
    
    # Train/Teståˆ†é›¢ã®æˆç¸¾
    st.markdown("### ğŸ“ˆ ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆçµæœï¼ˆTrain/Teståˆ†é›¢ï¼‰")
    
    train_metrics = ai_data.get("train_metrics", {})
    test_metrics = ai_data.get("test_metrics", {})
    
    if train_metrics and test_metrics:
        train_col, test_col = st.columns(2)
        
        with train_col:
            st.markdown("#### ğŸ“š å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆTrainï¼‰")
            train_years = train_metrics.get("years", [])
            st.markdown(f"**å¯¾è±¡å¹´**: {', '.join(map(str, train_years)) if train_years else 'ä¸æ˜'}")
            st.metric("å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æ•°", f"{train_metrics.get('total_races', 0):,}")
            st.metric("çš„ä¸­ç‡", f"{train_metrics.get('hit_rate', 0)*100:.2f}%")
            st.metric("å›åç‡", f"{train_metrics.get('recovery_rate', 0)*100:.2f}%")
        
        with test_col:
            st.markdown("#### ğŸ§ª ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ï¼ˆTestï¼‰")
            test_years = test_metrics.get("years", [])
            st.markdown(f"**å¯¾è±¡å¹´**: {', '.join(map(str, test_years)) if test_years else 'ä¸æ˜'}")
            st.metric("å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æ•°", f"{test_metrics.get('total_races', 0):,}")
            st.metric("çš„ä¸­ç‡", f"{test_metrics.get('hit_rate', 0)*100:.2f}%")
            st.metric("å›åç‡", f"{test_metrics.get('recovery_rate', 0)*100:.2f}%")
        
        # éå­¦ç¿’ãƒã‚§ãƒƒã‚¯
        train_recovery = train_metrics.get("recovery_rate", 0)
        test_recovery = test_metrics.get("recovery_rate", 0)
        
        if train_recovery > 0 and test_recovery > 0:
            overfit_ratio = train_recovery / test_recovery if test_recovery > 0 else float('inf')
            
            st.markdown("---")
            st.markdown("### âš ï¸ éå­¦ç¿’ãƒã‚§ãƒƒã‚¯")
            
            if overfit_ratio > 2.0:
                st.error(f"âš ï¸ **éå­¦ç¿’ã®å¯èƒ½æ€§ã‚ã‚Š**: Trainå›åç‡ãŒTestå›åç‡ã®{overfit_ratio:.1f}å€ã§ã™ã€‚ãƒ¢ãƒ‡ãƒ«ã®è¦‹ç›´ã—ã‚’æ¨å¥¨ã—ã¾ã™ã€‚")
            elif overfit_ratio > 1.5:
                st.warning(f"âš¡ **è»½åº¦ã®éå­¦ç¿’**: Trainå›åç‡ãŒTestå›åç‡ã®{overfit_ratio:.1f}å€ã§ã™ã€‚æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚")
            else:
                st.success(f"âœ… **è‰¯å¥½**: Train/Testé–“ã®å·®ç•°ã¯è¨±å®¹ç¯„å›²å†…ã§ã™ï¼ˆæ¯”ç‡: {overfit_ratio:.2f}ï¼‰")
    else:
        # æ—§å½¢å¼ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        metrics = ai_data.get("metrics", {})
        if metrics:
            st.markdown("#### ğŸ“Š å…¨ä½“æˆç¸¾")
            st.metric("å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æ•°", f"{metrics.get('total_races', 0):,}")
            st.metric("çš„ä¸­ç‡", f"{metrics.get('hit_rate', 0)*100:.2f}%")
            st.metric("å›åç‡", f"{metrics.get('recovery_rate', 0)*100:.2f}%")
            
            st.warning("âš ï¸ Train/Teståˆ†é›¢ã•ã‚Œã¦ã„ãªã„æ—§å½¢å¼ã®ãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚`ensemble_agents.py --optimize` ã‚’å®Ÿè¡Œã—ã¦æ›´æ–°ã—ã¦ãã ã•ã„ã€‚")
        else:
            st.info("ğŸ“­ AIå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`ensemble_agents.py --optimize` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
    
    st.markdown("---")
    
    # æ›´æ–°æƒ…å ±
    updated_at = ai_data.get("updated_at", "")
    if updated_at:
        st.markdown(f"**æœ€çµ‚æ›´æ–°**: {updated_at}")


# === ã‚¿ãƒ–7: ã‚·ã‚¹ãƒ†ãƒ  ===
with tab7:
    st.header("âš™ï¸ ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±")

    # ãƒ‡ãƒ¼ã‚¿çµ±è¨ˆ
    st.markdown("### ğŸ“Š ãƒ‡ãƒ¼ã‚¿çµ±è¨ˆ")

    pred_count = len(list(DATA_DIR.glob(f"{PREDICTIONS_PREFIX}*.json")))
    res_count = len(list(DATA_DIR.glob(f"{RESULTS_PREFIX}*.json")))

    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("ğŸ“ äºˆæƒ³ãƒ•ã‚¡ã‚¤ãƒ«", f"{pred_count}ä»¶")
    with col2:
        st.metric("ğŸ“Š çµæœãƒ•ã‚¡ã‚¤ãƒ«", f"{res_count}ä»¶")
    with col3:
        st.metric("ğŸ“… ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æ—¥æ•°", f"{len(available_dates)}æ—¥")

    st.markdown("---")

    # ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµ±è¨ˆ
    st.markdown("### ğŸ“š ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµ±è¨ˆ")

    index_data = load_archive_index()
    if index_data:
        years_data = index_data.get("years", {})
        for year in sorted(years_data.keys(), reverse=True):
            year_info = years_data[year]
            st.markdown(f"**{year}å¹´**: {year_info.get('total_dates', 0)}æ—¥ / {year_info.get('total_races', 0)}ãƒ¬ãƒ¼ã‚¹")
    else:
        st.info("ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`--rebuild-index` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")

    st.markdown("---")

    # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çŠ¶æ…‹
    st.markdown("### ğŸ”„ GitHub Actions ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼")

    st.markdown("""
    | ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ | ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« | èª¬æ˜ |
    |-------------|-------------|------|
    | ğŸ äºˆæƒ³ãƒ‡ãƒ¼ã‚¿å–å¾— | åœŸæ—¥ 07:00 JST | ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼‹ã‚¹ã‚³ã‚¢è¨ˆç®— |
    | ğŸ“Š ãƒ¬ãƒ¼ã‚¹çµæœå–å¾— | åœŸæ—¥ 18:00 JST | çµæœï¼‹æ‰•æˆ»é‡‘å–å¾— |
    | ğŸ’¹ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚ªãƒƒã‚º | æ‰‹å‹•å®Ÿè¡Œ | ç›´å‰ã‚ªãƒƒã‚ºå–å¾—ï¼‹ã‚¤ãƒ³ã‚µã‚¤ãƒ€ãƒ¼æ¤œçŸ¥ |
    | ğŸ“š éå»ãƒ‡ãƒ¼ã‚¿ä¸€æ‹¬å–å¾— | æ‰‹å‹•å®Ÿè¡Œ | éå»2å¹´åˆ†ã®ãƒ‡ãƒ¼ã‚¿åé›† |
    | ğŸ§  AIå­¦ç¿’ | é€±1å›ï¼ˆæœˆæ›œï¼‰ | é‡ã¿æœ€é©åŒ–ï¼‹ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ |
    """)

    st.markdown("---")

    # ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
    st.markdown("### ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±")

    st.code(f"""
UMA-Logic PRO v2.1 (ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«å­¦ç¿’å¯¾å¿œ)
Python: {sys.version.split()[0]}
Streamlit: {st.__version__}
Plotly: {'Available' if PLOTLY_AVAILABLE else 'Not Available'}
AgGrid: {'Available' if AGGRID_AVAILABLE else 'Not Available'}
ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {DATA_DIR.absolute()}
ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {ARCHIVE_DIR.absolute()}
ãƒ¢ãƒ‡ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {MODELS_DIR.absolute()}
é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«: {WEIGHTS_FILE.absolute()}
    """)

================================================================================
[4] .github/workflows/optimize_2025.yml - AIå­¦ç¿’ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
================================================================================
# .github/workflows/optimize_2025.yml
# UMA-Logic PRO - 2025å¹´ãƒ‡ãƒ¼ã‚¿ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼†AIå­¦ç¿’
# ã‚¹ãƒãƒ›ã‹ã‚‰ãƒœã‚¿ãƒ³ä¸€ã¤ã§å®Ÿè¡Œå¯èƒ½

name: ğŸ§ª 2025å¹´ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

on:
  workflow_dispatch:
    inputs:
      learning_rate:
        description: 'å­¦ç¿’ç‡ï¼ˆ0.01-0.5ï¼‰'
        required: false
        default: '0.1'
      iterations:
        description: 'æœ€é©åŒ–ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ•°'
        required: false
        default: '100'
      notify:
        description: 'é€šçŸ¥ã‚’é€ä¿¡ã™ã‚‹'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  TZ: Asia/Tokyo

jobs:
  simulate-2025:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      # 1. ç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      - name: ğŸ“¥ ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ğŸ Pythonç’°å¢ƒã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ“¦ ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
        run: |
          mkdir -p data/archive
          mkdir -p data/models

      # 2. ãƒ‡ãƒ¼ã‚¿æº–å‚™
      - name: ğŸ“‚ å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å½¢å¼ã«æ•´ç†
        run: python scripts/archive_manager.py --archive-all || echo "Archive step skipped"

      - name: ğŸ” ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å†æ§‹ç¯‰
        run: python scripts/archive_manager.py --rebuild-index || echo "Index rebuild skipped"

      # 3. 2025å¹´ãƒ‡ãƒ¼ã‚¿ã§AIå­¦ç¿’
      - name: ğŸ§  2025å¹´ãƒ‡ãƒ¼ã‚¿ã§AIå­¦ç¿’ã‚’å®Ÿè¡Œ
        id: optimize
        run: |
          python scripts/ensemble_agents.py --optimize --source data/archive/2025 \
            --learning-rate ${{ github.event.inputs.learning_rate }} \
            --iterations ${{ github.event.inputs.iterations }}
          
          # çµæœã‚’å–å¾—ã—ã¦ãƒ­ã‚°ã«å‡ºåŠ›
          if [ -f "data/models/weights.json" ]; then
            HIT_RATE=$(python3 -c "import json; print(json.load(open('data/models/weights.json')).get('test_metrics', {}).get('hit_rate', 0))" 2>/dev/null || echo "0")
            ROI=$(python3 -c "import json; print(json.load(open('data/models/weights.json')).get('test_metrics', {}).get('recovery_rate', 0))" 2>/dev/null || echo "0")
            echo "hit_rate=$HIT_RATE" >> $GITHUB_OUTPUT
            echo "roi=$ROI" >> $GITHUB_OUTPUT
          fi

      # 4. çµæœã‚’è‡ªå‹•ä¿å­˜ï¼ˆä¿®æ­£ç‰ˆï¼šstashã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆå›é¿ï¼‰
      - name: ğŸ’¾ å­¦ç¿’çµæœã‚’ãƒªãƒã‚¸ãƒˆãƒªã«è‡ªå‹•ä¿å­˜
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "UMA-Logic Bot"
          
          # å¤‰æ›´ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
          git add data/models/weights.json data/archive/ || true
          
          # å¤‰æ›´ãŒã‚ã‚‹å ´åˆã®ã¿ã‚³ãƒŸãƒƒãƒˆ
          if ! git diff --staged --quiet; then
            # ä¸€æ™‚çš„ã«stashã—ã¦æœ€æ–°ã‚’å–å¾—
            git stash push -m "temp-changes" || true
            
            # æœ€æ–°ã‚’å–å¾—ï¼ˆã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆå›é¿ï¼‰
            git fetch origin main
            git reset --hard origin/main
            
            # stashã‚’æˆ»ã™ï¼ˆã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚Œã°ä¸Šæ›¸ãï¼‰
            git stash pop || git checkout stash -- . || true
            
            # å†åº¦ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã—ã¦ã‚³ãƒŸãƒƒãƒˆ
            git add data/models/weights.json data/archive/ || true
            git commit -m "ğŸ§ª 2025å¹´ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº† - $(date +'%Y-%m-%d %H:%M')" || true
            git push origin main || true
          else
            echo "No changes to commit"
          fi

      # 5. å®Œäº†é€šçŸ¥
      - name: ğŸ“± é€šçŸ¥ã‚’é€ä¿¡
        if: github.event.inputs.notify != 'false'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: python scripts/notifier.py --type optimize --status success || echo "Notification skipped"

================================================================================
[5] data/models/weights.json - AIé‡ã¿è¨­å®š
================================================================================
{
  "weights": {
    "SpeedAgent": 0.3604030456565657,
    "AdaptabilityAgent": 0.34945614937111497,
    "PedigreeFormAgent": 0.29014080497231914
  },
  "updated_at": "2026-02-03 23:57:04",
  "train_metrics": {
    "years": [
      2024
    ],
    "total_races": 7586,
    "hit_rate": 0.4671763775375692,
    "recovery_rate": 1.2614579488531505
  },
  "test_metrics": {
    "years": [
      2025
    ],
    "total_races": 7788,
    "hit_rate": 0.4478685156651258,
    "recovery_rate": 1.216502311248074
  },
  "metrics": {
    "total_races": 7788,
    "correct_predictions": 3488,
    "hit_rate": 0.4478685156651258,
    "recovery_rate": 1.216502311248074,
    "total_investment": 778800,
    "total_return": 947412
  }
}
================================================================================
[END OF AUDIT PACKAGE]
================================================================================
